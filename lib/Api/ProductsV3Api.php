<?php
/**
 * ProductsV3Api
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client\Otto
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * OTTO Market API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Otto\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\Otto\ApiException;
use OpenAPI\Client\Otto\Configuration;
use OpenAPI\Client\Otto\HeaderSelector;
use OpenAPI\Client\Otto\ObjectSerializer;

/**
 * ProductsV3Api Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client\Otto
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ProductsV3Api
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'productsV3CreateOrUpdateProductVariations' => [
            'application/json',
        ],
        'productsV3FailedByProcessId' => [
            'application/json',
        ],
        'productsV3GetActiveStatus' => [
            'application/json',
        ],
        'productsV3GetBrands' => [
            'application/json',
        ],
        'productsV3GetCategoryGroups' => [
            'application/json',
        ],
        'productsV3GetContentChanges' => [
            'application/json',
        ],
        'productsV3GetContentChanges2' => [
            'application/json',
        ],
        'productsV3GetMarketPlaceStatus' => [
            'application/json',
        ],
        'productsV3GetMarketPlaceStatusList' => [
            'application/json',
        ],
        'productsV3GetPartnerProducts' => [
            'application/json',
        ],
        'productsV3GetProductVariation' => [
            'application/json',
        ],
        'productsV3GetProductVariationPrice' => [
            'application/json',
        ],
        'productsV3GetProductVariationPrices' => [
            'application/json',
        ],
        'productsV3GetVariationActiveStatus' => [
            'application/json',
        ],
        'productsV3ProgressByProcessId' => [
            'application/json',
        ],
        'productsV3SucceededByProcessId' => [
            'application/json',
        ],
        'productsV3UnchangedByProcessId' => [
            'application/json',
        ],
        'productsV3UpdateActiveStatus' => [
            'application/json',
        ],
        'productsV3UpdateProductVariationPrices' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation productsV3CreateOrUpdateProductVariations
     *
     * Create or update product variations
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ProductVariationProductsV3[]|null $productVariationProductsV3 productVariationProductsV3 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3CreateOrUpdateProductVariations'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3
     */
    public function productsV3CreateOrUpdateProductVariations($xRequestTimestamp = null, $productVariationProductsV3 = null, string $contentType = self::contentTypes['productsV3CreateOrUpdateProductVariations'][0])
    {
        list($response) = $this->productsV3CreateOrUpdateProductVariationsWithHttpInfo($xRequestTimestamp, $productVariationProductsV3, $contentType);
        return $response;
    }

    /**
     * Operation productsV3CreateOrUpdateProductVariationsWithHttpInfo
     *
     * Create or update product variations
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ProductVariationProductsV3[]|null $productVariationProductsV3 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3CreateOrUpdateProductVariations'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV3CreateOrUpdateProductVariationsWithHttpInfo($xRequestTimestamp = null, $productVariationProductsV3 = null, string $contentType = self::contentTypes['productsV3CreateOrUpdateProductVariations'][0])
    {
        $request = $this->productsV3CreateOrUpdateProductVariationsRequest($xRequestTimestamp, $productVariationProductsV3, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV3CreateOrUpdateProductVariationsAsync
     *
     * Create or update product variations
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ProductVariationProductsV3[]|null $productVariationProductsV3 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3CreateOrUpdateProductVariations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3CreateOrUpdateProductVariationsAsync($xRequestTimestamp = null, $productVariationProductsV3 = null, string $contentType = self::contentTypes['productsV3CreateOrUpdateProductVariations'][0])
    {
        return $this->productsV3CreateOrUpdateProductVariationsAsyncWithHttpInfo($xRequestTimestamp, $productVariationProductsV3, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV3CreateOrUpdateProductVariationsAsyncWithHttpInfo
     *
     * Create or update product variations
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ProductVariationProductsV3[]|null $productVariationProductsV3 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3CreateOrUpdateProductVariations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3CreateOrUpdateProductVariationsAsyncWithHttpInfo($xRequestTimestamp = null, $productVariationProductsV3 = null, string $contentType = self::contentTypes['productsV3CreateOrUpdateProductVariations'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3';
        $request = $this->productsV3CreateOrUpdateProductVariationsRequest($xRequestTimestamp, $productVariationProductsV3, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV3CreateOrUpdateProductVariations'
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ProductVariationProductsV3[]|null $productVariationProductsV3 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3CreateOrUpdateProductVariations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV3CreateOrUpdateProductVariationsRequest($xRequestTimestamp = null, $productVariationProductsV3 = null, string $contentType = self::contentTypes['productsV3CreateOrUpdateProductVariations'][0])
    {




        $resourcePath = '/v3/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($xRequestTimestamp !== null) {
            $headerParams['X-Request-Timestamp'] = ObjectSerializer::toHeaderValue($xRequestTimestamp);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($productVariationProductsV3)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($productVariationProductsV3));
            } else {
                $httpBody = $productVariationProductsV3;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV3FailedByProcessId
     *
     * List failed products of a product data delivery
     *
     * @param  string $processUuid search for the failed products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3FailedByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3
     */
    public function productsV3FailedByProcessId($processUuid, string $contentType = self::contentTypes['productsV3FailedByProcessId'][0])
    {
        list($response) = $this->productsV3FailedByProcessIdWithHttpInfo($processUuid, $contentType);
        return $response;
    }

    /**
     * Operation productsV3FailedByProcessIdWithHttpInfo
     *
     * List failed products of a product data delivery
     *
     * @param  string $processUuid search for the failed products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3FailedByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV3FailedByProcessIdWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV3FailedByProcessId'][0])
    {
        $request = $this->productsV3FailedByProcessIdRequest($processUuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV3FailedByProcessIdAsync
     *
     * List failed products of a product data delivery
     *
     * @param  string $processUuid search for the failed products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3FailedByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3FailedByProcessIdAsync($processUuid, string $contentType = self::contentTypes['productsV3FailedByProcessId'][0])
    {
        return $this->productsV3FailedByProcessIdAsyncWithHttpInfo($processUuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV3FailedByProcessIdAsyncWithHttpInfo
     *
     * List failed products of a product data delivery
     *
     * @param  string $processUuid search for the failed products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3FailedByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3FailedByProcessIdAsyncWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV3FailedByProcessId'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3';
        $request = $this->productsV3FailedByProcessIdRequest($processUuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV3FailedByProcessId'
     *
     * @param  string $processUuid search for the failed products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3FailedByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV3FailedByProcessIdRequest($processUuid, string $contentType = self::contentTypes['productsV3FailedByProcessId'][0])
    {

        // verify the required parameter 'processUuid' is set
        if ($processUuid === null || (is_array($processUuid) && count($processUuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $processUuid when calling productsV3FailedByProcessId'
            );
        }


        $resourcePath = '/v3/products/update-tasks/{processUuid}/failed';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($processUuid !== null) {
            $resourcePath = str_replace(
                '{' . 'processUuid' . '}',
                ObjectSerializer::toPathValue($processUuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV3GetActiveStatus
     *
     * Read active status
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brand ID value (optional)
     * @param  int|null $page page (optional)
     * @param  int|null $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetActiveStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV3
     */
    public function productsV3GetActiveStatus($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetActiveStatus'][0])
    {
        list($response) = $this->productsV3GetActiveStatusWithHttpInfo($sku, $productReference, $category, $brandId, $page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation productsV3GetActiveStatusWithHttpInfo
     *
     * Read active status
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brand ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetActiveStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV3, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV3GetActiveStatusWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetActiveStatus'][0])
    {
        $request = $this->productsV3GetActiveStatusRequest($sku, $productReference, $category, $brandId, $page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV3' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV3' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV3', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV3';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV3GetActiveStatusAsync
     *
     * Read active status
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brand ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetActiveStatusAsync($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetActiveStatus'][0])
    {
        return $this->productsV3GetActiveStatusAsyncWithHttpInfo($sku, $productReference, $category, $brandId, $page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV3GetActiveStatusAsyncWithHttpInfo
     *
     * Read active status
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brand ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetActiveStatusAsyncWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetActiveStatus'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV3';
        $request = $this->productsV3GetActiveStatusRequest($sku, $productReference, $category, $brandId, $page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV3GetActiveStatus'
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brand ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV3GetActiveStatusRequest($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetActiveStatus'][0])
    {








        $resourcePath = '/v3/products/active-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $productReference,
            'productReference', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brandId,
            'brandId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV3GetBrands
     *
     * List of allowed brands
     *
     * @param  string|null $ifMatch The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string|null $ifNoneMatch The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string|null $ifModifiedSince The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#39;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#39;s data is avoided if that data has not changed. (optional)
     * @param  string|null $ifUnmodifiedSince The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#39;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int|null $page page (optional)
     * @param  int|null $limit limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetBrands'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\BrandListResponseProductsV3
     */
    public function productsV3GetBrands($ifMatch = null, $ifNoneMatch = null, $ifModifiedSince = null, $ifUnmodifiedSince = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetBrands'][0])
    {
        list($response) = $this->productsV3GetBrandsWithHttpInfo($ifMatch, $ifNoneMatch, $ifModifiedSince, $ifUnmodifiedSince, $page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation productsV3GetBrandsWithHttpInfo
     *
     * List of allowed brands
     *
     * @param  string|null $ifMatch The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string|null $ifNoneMatch The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string|null $ifModifiedSince The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#39;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#39;s data is avoided if that data has not changed. (optional)
     * @param  string|null $ifUnmodifiedSince The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#39;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetBrands'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\BrandListResponseProductsV3, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV3GetBrandsWithHttpInfo($ifMatch = null, $ifNoneMatch = null, $ifModifiedSince = null, $ifUnmodifiedSince = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetBrands'][0])
    {
        $request = $this->productsV3GetBrandsRequest($ifMatch, $ifNoneMatch, $ifModifiedSince, $ifUnmodifiedSince, $page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\BrandListResponseProductsV3' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\BrandListResponseProductsV3' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\BrandListResponseProductsV3', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\BrandListResponseProductsV3';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\BrandListResponseProductsV3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV3GetBrandsAsync
     *
     * List of allowed brands
     *
     * @param  string|null $ifMatch The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string|null $ifNoneMatch The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string|null $ifModifiedSince The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#39;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#39;s data is avoided if that data has not changed. (optional)
     * @param  string|null $ifUnmodifiedSince The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#39;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetBrands'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetBrandsAsync($ifMatch = null, $ifNoneMatch = null, $ifModifiedSince = null, $ifUnmodifiedSince = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetBrands'][0])
    {
        return $this->productsV3GetBrandsAsyncWithHttpInfo($ifMatch, $ifNoneMatch, $ifModifiedSince, $ifUnmodifiedSince, $page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV3GetBrandsAsyncWithHttpInfo
     *
     * List of allowed brands
     *
     * @param  string|null $ifMatch The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string|null $ifNoneMatch The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string|null $ifModifiedSince The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#39;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#39;s data is avoided if that data has not changed. (optional)
     * @param  string|null $ifUnmodifiedSince The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#39;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetBrands'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetBrandsAsyncWithHttpInfo($ifMatch = null, $ifNoneMatch = null, $ifModifiedSince = null, $ifUnmodifiedSince = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetBrands'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\BrandListResponseProductsV3';
        $request = $this->productsV3GetBrandsRequest($ifMatch, $ifNoneMatch, $ifModifiedSince, $ifUnmodifiedSince, $page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV3GetBrands'
     *
     * @param  string|null $ifMatch The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string|null $ifNoneMatch The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string|null $ifModifiedSince The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#39;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#39;s data is avoided if that data has not changed. (optional)
     * @param  string|null $ifUnmodifiedSince The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#39;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetBrands'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV3GetBrandsRequest($ifMatch = null, $ifNoneMatch = null, $ifModifiedSince = null, $ifUnmodifiedSince = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetBrands'][0])
    {








        $resourcePath = '/v3/products/brands';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($ifMatch !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($ifMatch);
        }
        // header params
        if ($ifNoneMatch !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($ifNoneMatch);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }
        // header params
        if ($ifUnmodifiedSince !== null) {
            $headerParams['If-Unmodified-Since'] = ObjectSerializer::toHeaderValue($ifUnmodifiedSince);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV3GetCategoryGroups
     *
     * Read product categories
     *
     * @param  int|null $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int|null $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string|null $category read a single category (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetCategoryGroups'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\CategoryGroupsProductsV3
     */
    public function productsV3GetCategoryGroups($page = null, $limit = null, $category = null, string $contentType = self::contentTypes['productsV3GetCategoryGroups'][0])
    {
        list($response) = $this->productsV3GetCategoryGroupsWithHttpInfo($page, $limit, $category, $contentType);
        return $response;
    }

    /**
     * Operation productsV3GetCategoryGroupsWithHttpInfo
     *
     * Read product categories
     *
     * @param  int|null $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int|null $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string|null $category read a single category (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetCategoryGroups'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\CategoryGroupsProductsV3, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV3GetCategoryGroupsWithHttpInfo($page = null, $limit = null, $category = null, string $contentType = self::contentTypes['productsV3GetCategoryGroups'][0])
    {
        $request = $this->productsV3GetCategoryGroupsRequest($page, $limit, $category, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\CategoryGroupsProductsV3' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\CategoryGroupsProductsV3' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\CategoryGroupsProductsV3', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\CategoryGroupsProductsV3';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\CategoryGroupsProductsV3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV3GetCategoryGroupsAsync
     *
     * Read product categories
     *
     * @param  int|null $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int|null $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string|null $category read a single category (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetCategoryGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetCategoryGroupsAsync($page = null, $limit = null, $category = null, string $contentType = self::contentTypes['productsV3GetCategoryGroups'][0])
    {
        return $this->productsV3GetCategoryGroupsAsyncWithHttpInfo($page, $limit, $category, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV3GetCategoryGroupsAsyncWithHttpInfo
     *
     * Read product categories
     *
     * @param  int|null $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int|null $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string|null $category read a single category (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetCategoryGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetCategoryGroupsAsyncWithHttpInfo($page = null, $limit = null, $category = null, string $contentType = self::contentTypes['productsV3GetCategoryGroups'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\CategoryGroupsProductsV3';
        $request = $this->productsV3GetCategoryGroupsRequest($page, $limit, $category, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV3GetCategoryGroups'
     *
     * @param  int|null $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int|null $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string|null $category read a single category (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetCategoryGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV3GetCategoryGroupsRequest($page = null, $limit = null, $category = null, string $contentType = self::contentTypes['productsV3GetCategoryGroups'][0])
    {





        $resourcePath = '/v3/products/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV3GetContentChanges
     *
     * Read content changes for a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime|null $fromDate search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page page (optional)
     * @param  int|null $limit proposed limit for the number of entries per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetContentChanges'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV3
     */
    public function productsV3GetContentChanges($sku, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetContentChanges'][0])
    {
        list($response) = $this->productsV3GetContentChangesWithHttpInfo($sku, $fromDate, $page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation productsV3GetContentChangesWithHttpInfo
     *
     * Read content changes for a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime|null $fromDate search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of entries per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetContentChanges'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV3, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV3GetContentChangesWithHttpInfo($sku, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetContentChanges'][0])
    {
        $request = $this->productsV3GetContentChangesRequest($sku, $fromDate, $page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV3' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV3' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV3', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV3';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV3GetContentChangesAsync
     *
     * Read content changes for a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime|null $fromDate search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of entries per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetContentChanges'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetContentChangesAsync($sku, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetContentChanges'][0])
    {
        return $this->productsV3GetContentChangesAsyncWithHttpInfo($sku, $fromDate, $page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV3GetContentChangesAsyncWithHttpInfo
     *
     * Read content changes for a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime|null $fromDate search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of entries per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetContentChanges'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetContentChangesAsyncWithHttpInfo($sku, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetContentChanges'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV3';
        $request = $this->productsV3GetContentChangesRequest($sku, $fromDate, $page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV3GetContentChanges'
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime|null $fromDate search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of entries per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetContentChanges'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV3GetContentChangesRequest($sku, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetContentChanges'][0])
    {

        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV3GetContentChanges'
            );
        }





        $resourcePath = '/v3/products/{sku}/content-changes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fromDate,
            'fromDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV3GetContentChanges2
     *
     * Read content changes within time period
     *
     * @param  string[]|null $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime|null $fromDate search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page page (optional)
     * @param  int|null $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetContentChanges2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV3
     */
    public function productsV3GetContentChanges2($sku = null, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetContentChanges2'][0])
    {
        list($response) = $this->productsV3GetContentChanges2WithHttpInfo($sku, $fromDate, $page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation productsV3GetContentChanges2WithHttpInfo
     *
     * Read content changes within time period
     *
     * @param  string[]|null $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime|null $fromDate search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetContentChanges2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV3, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV3GetContentChanges2WithHttpInfo($sku = null, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetContentChanges2'][0])
    {
        $request = $this->productsV3GetContentChanges2Request($sku, $fromDate, $page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV3' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV3' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV3', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV3';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV3GetContentChanges2Async
     *
     * Read content changes within time period
     *
     * @param  string[]|null $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime|null $fromDate search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetContentChanges2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetContentChanges2Async($sku = null, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetContentChanges2'][0])
    {
        return $this->productsV3GetContentChanges2AsyncWithHttpInfo($sku, $fromDate, $page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV3GetContentChanges2AsyncWithHttpInfo
     *
     * Read content changes within time period
     *
     * @param  string[]|null $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime|null $fromDate search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetContentChanges2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetContentChanges2AsyncWithHttpInfo($sku = null, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetContentChanges2'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV3';
        $request = $this->productsV3GetContentChanges2Request($sku, $fromDate, $page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV3GetContentChanges2'
     *
     * @param  string[]|null $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime|null $fromDate search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetContentChanges2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV3GetContentChanges2Request($sku = null, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetContentChanges2'][0])
    {






        $resourcePath = '/v3/products/content-changes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fromDate,
            'fromDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV3GetMarketPlaceStatus
     *
     * Read marketplace status for a single product variation
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetMarketPlaceStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV3
     */
    public function productsV3GetMarketPlaceStatus($sku, string $contentType = self::contentTypes['productsV3GetMarketPlaceStatus'][0])
    {
        list($response) = $this->productsV3GetMarketPlaceStatusWithHttpInfo($sku, $contentType);
        return $response;
    }

    /**
     * Operation productsV3GetMarketPlaceStatusWithHttpInfo
     *
     * Read marketplace status for a single product variation
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetMarketPlaceStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV3, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV3GetMarketPlaceStatusWithHttpInfo($sku, string $contentType = self::contentTypes['productsV3GetMarketPlaceStatus'][0])
    {
        $request = $this->productsV3GetMarketPlaceStatusRequest($sku, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV3' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV3' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV3', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV3';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV3GetMarketPlaceStatusAsync
     *
     * Read marketplace status for a single product variation
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetMarketPlaceStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetMarketPlaceStatusAsync($sku, string $contentType = self::contentTypes['productsV3GetMarketPlaceStatus'][0])
    {
        return $this->productsV3GetMarketPlaceStatusAsyncWithHttpInfo($sku, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV3GetMarketPlaceStatusAsyncWithHttpInfo
     *
     * Read marketplace status for a single product variation
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetMarketPlaceStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetMarketPlaceStatusAsyncWithHttpInfo($sku, string $contentType = self::contentTypes['productsV3GetMarketPlaceStatus'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV3';
        $request = $this->productsV3GetMarketPlaceStatusRequest($sku, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV3GetMarketPlaceStatus'
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetMarketPlaceStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV3GetMarketPlaceStatusRequest($sku, string $contentType = self::contentTypes['productsV3GetMarketPlaceStatus'][0])
    {

        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV3GetMarketPlaceStatus'
            );
        }


        $resourcePath = '/v3/products/{sku}/marketplace-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV3GetMarketPlaceStatusList
     *
     * Read marketplace status of product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string|null $category search marketplace status by the category value of the related product variations (optional)
     * @param  string|null $brandId search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime|null $fromDate search marketplace status for a time range starting with the given date (in ISO8601, like &#39;2021-10-09T07:52:19.820Z&#39; or &#39;2021-10-09T07:52:19.820+01:00&#39;) (optional)
     * @param  int|null $page page to load (optional)
     * @param  int|null $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[]|null $marketPlaceStatus only include items that match any of the provided status (optional)
     * @param  string|null $sortOrder Define the sort order of the resulting entries. Available values are &#39;desc&#39; for &#39;newest lastModified first&#39; and &#39;asc&#39; for &#39;oldest lastModified first&#39; - default is &#39;desc&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetMarketPlaceStatusList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV3
     */
    public function productsV3GetMarketPlaceStatusList($sku = null, $productReference = null, $category = null, $brandId = null, $fromDate = null, $page = null, $limit = null, $marketPlaceStatus = null, $sortOrder = null, string $contentType = self::contentTypes['productsV3GetMarketPlaceStatusList'][0])
    {
        list($response) = $this->productsV3GetMarketPlaceStatusListWithHttpInfo($sku, $productReference, $category, $brandId, $fromDate, $page, $limit, $marketPlaceStatus, $sortOrder, $contentType);
        return $response;
    }

    /**
     * Operation productsV3GetMarketPlaceStatusListWithHttpInfo
     *
     * Read marketplace status of product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string|null $category search marketplace status by the category value of the related product variations (optional)
     * @param  string|null $brandId search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime|null $fromDate search marketplace status for a time range starting with the given date (in ISO8601, like &#39;2021-10-09T07:52:19.820Z&#39; or &#39;2021-10-09T07:52:19.820+01:00&#39;) (optional)
     * @param  int|null $page page to load (optional)
     * @param  int|null $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[]|null $marketPlaceStatus only include items that match any of the provided status (optional)
     * @param  string|null $sortOrder Define the sort order of the resulting entries. Available values are &#39;desc&#39; for &#39;newest lastModified first&#39; and &#39;asc&#39; for &#39;oldest lastModified first&#39; - default is &#39;desc&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetMarketPlaceStatusList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV3, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV3GetMarketPlaceStatusListWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $fromDate = null, $page = null, $limit = null, $marketPlaceStatus = null, $sortOrder = null, string $contentType = self::contentTypes['productsV3GetMarketPlaceStatusList'][0])
    {
        $request = $this->productsV3GetMarketPlaceStatusListRequest($sku, $productReference, $category, $brandId, $fromDate, $page, $limit, $marketPlaceStatus, $sortOrder, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV3' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV3' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV3', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV3';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV3GetMarketPlaceStatusListAsync
     *
     * Read marketplace status of product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string|null $category search marketplace status by the category value of the related product variations (optional)
     * @param  string|null $brandId search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime|null $fromDate search marketplace status for a time range starting with the given date (in ISO8601, like &#39;2021-10-09T07:52:19.820Z&#39; or &#39;2021-10-09T07:52:19.820+01:00&#39;) (optional)
     * @param  int|null $page page to load (optional)
     * @param  int|null $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[]|null $marketPlaceStatus only include items that match any of the provided status (optional)
     * @param  string|null $sortOrder Define the sort order of the resulting entries. Available values are &#39;desc&#39; for &#39;newest lastModified first&#39; and &#39;asc&#39; for &#39;oldest lastModified first&#39; - default is &#39;desc&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetMarketPlaceStatusList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetMarketPlaceStatusListAsync($sku = null, $productReference = null, $category = null, $brandId = null, $fromDate = null, $page = null, $limit = null, $marketPlaceStatus = null, $sortOrder = null, string $contentType = self::contentTypes['productsV3GetMarketPlaceStatusList'][0])
    {
        return $this->productsV3GetMarketPlaceStatusListAsyncWithHttpInfo($sku, $productReference, $category, $brandId, $fromDate, $page, $limit, $marketPlaceStatus, $sortOrder, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV3GetMarketPlaceStatusListAsyncWithHttpInfo
     *
     * Read marketplace status of product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string|null $category search marketplace status by the category value of the related product variations (optional)
     * @param  string|null $brandId search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime|null $fromDate search marketplace status for a time range starting with the given date (in ISO8601, like &#39;2021-10-09T07:52:19.820Z&#39; or &#39;2021-10-09T07:52:19.820+01:00&#39;) (optional)
     * @param  int|null $page page to load (optional)
     * @param  int|null $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[]|null $marketPlaceStatus only include items that match any of the provided status (optional)
     * @param  string|null $sortOrder Define the sort order of the resulting entries. Available values are &#39;desc&#39; for &#39;newest lastModified first&#39; and &#39;asc&#39; for &#39;oldest lastModified first&#39; - default is &#39;desc&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetMarketPlaceStatusList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetMarketPlaceStatusListAsyncWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $fromDate = null, $page = null, $limit = null, $marketPlaceStatus = null, $sortOrder = null, string $contentType = self::contentTypes['productsV3GetMarketPlaceStatusList'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV3';
        $request = $this->productsV3GetMarketPlaceStatusListRequest($sku, $productReference, $category, $brandId, $fromDate, $page, $limit, $marketPlaceStatus, $sortOrder, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV3GetMarketPlaceStatusList'
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string|null $category search marketplace status by the category value of the related product variations (optional)
     * @param  string|null $brandId search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime|null $fromDate search marketplace status for a time range starting with the given date (in ISO8601, like &#39;2021-10-09T07:52:19.820Z&#39; or &#39;2021-10-09T07:52:19.820+01:00&#39;) (optional)
     * @param  int|null $page page to load (optional)
     * @param  int|null $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[]|null $marketPlaceStatus only include items that match any of the provided status (optional)
     * @param  string|null $sortOrder Define the sort order of the resulting entries. Available values are &#39;desc&#39; for &#39;newest lastModified first&#39; and &#39;asc&#39; for &#39;oldest lastModified first&#39; - default is &#39;desc&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetMarketPlaceStatusList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV3GetMarketPlaceStatusListRequest($sku = null, $productReference = null, $category = null, $brandId = null, $fromDate = null, $page = null, $limit = null, $marketPlaceStatus = null, $sortOrder = null, string $contentType = self::contentTypes['productsV3GetMarketPlaceStatusList'][0])
    {











        $resourcePath = '/v3/products/marketplace-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $productReference,
            'productReference', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brandId,
            'brandId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fromDate,
            'fromDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $marketPlaceStatus,
            'marketPlaceStatus', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sortOrder,
            'sort-order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV3GetPartnerProducts
     *
     * Read product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brandId value (optional)
     * @param  int|null $page page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetPartnerProducts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV3
     */
    public function productsV3GetPartnerProducts($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetPartnerProducts'][0])
    {
        list($response) = $this->productsV3GetPartnerProductsWithHttpInfo($sku, $productReference, $category, $brandId, $page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation productsV3GetPartnerProductsWithHttpInfo
     *
     * Read product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brandId value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetPartnerProducts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV3, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV3GetPartnerProductsWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetPartnerProducts'][0])
    {
        $request = $this->productsV3GetPartnerProductsRequest($sku, $productReference, $category, $brandId, $page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV3' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV3' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV3', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV3';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV3GetPartnerProductsAsync
     *
     * Read product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brandId value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetPartnerProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetPartnerProductsAsync($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetPartnerProducts'][0])
    {
        return $this->productsV3GetPartnerProductsAsyncWithHttpInfo($sku, $productReference, $category, $brandId, $page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV3GetPartnerProductsAsyncWithHttpInfo
     *
     * Read product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brandId value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetPartnerProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetPartnerProductsAsyncWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetPartnerProducts'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV3';
        $request = $this->productsV3GetPartnerProductsRequest($sku, $productReference, $category, $brandId, $page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV3GetPartnerProducts'
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brandId value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetPartnerProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV3GetPartnerProductsRequest($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetPartnerProducts'][0])
    {








        $resourcePath = '/v3/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $productReference,
            'productReference', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brandId,
            'brandId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV3GetProductVariation
     *
     * Read a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetProductVariation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductVariationProductsV3
     */
    public function productsV3GetProductVariation($sku, string $contentType = self::contentTypes['productsV3GetProductVariation'][0])
    {
        list($response) = $this->productsV3GetProductVariationWithHttpInfo($sku, $contentType);
        return $response;
    }

    /**
     * Operation productsV3GetProductVariationWithHttpInfo
     *
     * Read a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetProductVariation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductVariationProductsV3, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV3GetProductVariationWithHttpInfo($sku, string $contentType = self::contentTypes['productsV3GetProductVariation'][0])
    {
        $request = $this->productsV3GetProductVariationRequest($sku, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ProductVariationProductsV3' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductVariationProductsV3' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductVariationProductsV3', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductVariationProductsV3';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductVariationProductsV3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV3GetProductVariationAsync
     *
     * Read a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetProductVariation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetProductVariationAsync($sku, string $contentType = self::contentTypes['productsV3GetProductVariation'][0])
    {
        return $this->productsV3GetProductVariationAsyncWithHttpInfo($sku, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV3GetProductVariationAsyncWithHttpInfo
     *
     * Read a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetProductVariation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetProductVariationAsyncWithHttpInfo($sku, string $contentType = self::contentTypes['productsV3GetProductVariation'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductVariationProductsV3';
        $request = $this->productsV3GetProductVariationRequest($sku, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV3GetProductVariation'
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetProductVariation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV3GetProductVariationRequest($sku, string $contentType = self::contentTypes['productsV3GetProductVariation'][0])
    {

        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV3GetProductVariation'
            );
        }


        $resourcePath = '/v3/products/{sku}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV3GetProductVariationPrice
     *
     * Read a single product variation price
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetProductVariationPrice'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\SkuPricingProductsV3
     */
    public function productsV3GetProductVariationPrice($sku, string $contentType = self::contentTypes['productsV3GetProductVariationPrice'][0])
    {
        list($response) = $this->productsV3GetProductVariationPriceWithHttpInfo($sku, $contentType);
        return $response;
    }

    /**
     * Operation productsV3GetProductVariationPriceWithHttpInfo
     *
     * Read a single product variation price
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetProductVariationPrice'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\SkuPricingProductsV3, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV3GetProductVariationPriceWithHttpInfo($sku, string $contentType = self::contentTypes['productsV3GetProductVariationPrice'][0])
    {
        $request = $this->productsV3GetProductVariationPriceRequest($sku, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\SkuPricingProductsV3' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\SkuPricingProductsV3' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\SkuPricingProductsV3', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\SkuPricingProductsV3';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\SkuPricingProductsV3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV3GetProductVariationPriceAsync
     *
     * Read a single product variation price
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetProductVariationPrice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetProductVariationPriceAsync($sku, string $contentType = self::contentTypes['productsV3GetProductVariationPrice'][0])
    {
        return $this->productsV3GetProductVariationPriceAsyncWithHttpInfo($sku, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV3GetProductVariationPriceAsyncWithHttpInfo
     *
     * Read a single product variation price
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetProductVariationPrice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetProductVariationPriceAsyncWithHttpInfo($sku, string $contentType = self::contentTypes['productsV3GetProductVariationPrice'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\SkuPricingProductsV3';
        $request = $this->productsV3GetProductVariationPriceRequest($sku, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV3GetProductVariationPrice'
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetProductVariationPrice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV3GetProductVariationPriceRequest($sku, string $contentType = self::contentTypes['productsV3GetProductVariationPrice'][0])
    {

        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV3GetProductVariationPrice'
            );
        }


        $resourcePath = '/v3/products/{sku}/prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV3GetProductVariationPrices
     *
     * Read product variations prices
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their ID value (optional)
     * @param  int|null $page page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\PriceApiResultProductsV3
     */
    public function productsV3GetProductVariationPrices($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetProductVariationPrices'][0])
    {
        list($response) = $this->productsV3GetProductVariationPricesWithHttpInfo($sku, $productReference, $category, $brandId, $page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation productsV3GetProductVariationPricesWithHttpInfo
     *
     * Read product variations prices
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\PriceApiResultProductsV3, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV3GetProductVariationPricesWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetProductVariationPrices'][0])
    {
        $request = $this->productsV3GetProductVariationPricesRequest($sku, $productReference, $category, $brandId, $page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\PriceApiResultProductsV3' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\PriceApiResultProductsV3' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\PriceApiResultProductsV3', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\PriceApiResultProductsV3';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\PriceApiResultProductsV3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV3GetProductVariationPricesAsync
     *
     * Read product variations prices
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetProductVariationPricesAsync($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetProductVariationPrices'][0])
    {
        return $this->productsV3GetProductVariationPricesAsyncWithHttpInfo($sku, $productReference, $category, $brandId, $page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV3GetProductVariationPricesAsyncWithHttpInfo
     *
     * Read product variations prices
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetProductVariationPricesAsyncWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetProductVariationPrices'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\PriceApiResultProductsV3';
        $request = $this->productsV3GetProductVariationPricesRequest($sku, $productReference, $category, $brandId, $page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV3GetProductVariationPrices'
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV3GetProductVariationPricesRequest($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV3GetProductVariationPrices'][0])
    {








        $resourcePath = '/v3/products/prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $productReference,
            'productReference', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brandId,
            'brandId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV3GetVariationActiveStatus
     *
     * Read the active status of a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetVariationActiveStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ActiveStatusProductsV3
     */
    public function productsV3GetVariationActiveStatus($sku, string $contentType = self::contentTypes['productsV3GetVariationActiveStatus'][0])
    {
        list($response) = $this->productsV3GetVariationActiveStatusWithHttpInfo($sku, $contentType);
        return $response;
    }

    /**
     * Operation productsV3GetVariationActiveStatusWithHttpInfo
     *
     * Read the active status of a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetVariationActiveStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ActiveStatusProductsV3, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV3GetVariationActiveStatusWithHttpInfo($sku, string $contentType = self::contentTypes['productsV3GetVariationActiveStatus'][0])
    {
        $request = $this->productsV3GetVariationActiveStatusRequest($sku, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ActiveStatusProductsV3' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ActiveStatusProductsV3' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ActiveStatusProductsV3', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ActiveStatusProductsV3';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ActiveStatusProductsV3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV3GetVariationActiveStatusAsync
     *
     * Read the active status of a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetVariationActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetVariationActiveStatusAsync($sku, string $contentType = self::contentTypes['productsV3GetVariationActiveStatus'][0])
    {
        return $this->productsV3GetVariationActiveStatusAsyncWithHttpInfo($sku, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV3GetVariationActiveStatusAsyncWithHttpInfo
     *
     * Read the active status of a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetVariationActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3GetVariationActiveStatusAsyncWithHttpInfo($sku, string $contentType = self::contentTypes['productsV3GetVariationActiveStatus'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ActiveStatusProductsV3';
        $request = $this->productsV3GetVariationActiveStatusRequest($sku, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV3GetVariationActiveStatus'
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3GetVariationActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV3GetVariationActiveStatusRequest($sku, string $contentType = self::contentTypes['productsV3GetVariationActiveStatus'][0])
    {

        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV3GetVariationActiveStatus'
            );
        }


        $resourcePath = '/v3/products/{sku}/active-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV3ProgressByProcessId
     *
     * Request the results of a product data delivery
     *
     * @param  string $processUuid search for a product data delivery result by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3ProgressByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3
     */
    public function productsV3ProgressByProcessId($processUuid, string $contentType = self::contentTypes['productsV3ProgressByProcessId'][0])
    {
        list($response) = $this->productsV3ProgressByProcessIdWithHttpInfo($processUuid, $contentType);
        return $response;
    }

    /**
     * Operation productsV3ProgressByProcessIdWithHttpInfo
     *
     * Request the results of a product data delivery
     *
     * @param  string $processUuid search for a product data delivery result by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3ProgressByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV3ProgressByProcessIdWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV3ProgressByProcessId'][0])
    {
        $request = $this->productsV3ProgressByProcessIdRequest($processUuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV3ProgressByProcessIdAsync
     *
     * Request the results of a product data delivery
     *
     * @param  string $processUuid search for a product data delivery result by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3ProgressByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3ProgressByProcessIdAsync($processUuid, string $contentType = self::contentTypes['productsV3ProgressByProcessId'][0])
    {
        return $this->productsV3ProgressByProcessIdAsyncWithHttpInfo($processUuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV3ProgressByProcessIdAsyncWithHttpInfo
     *
     * Request the results of a product data delivery
     *
     * @param  string $processUuid search for a product data delivery result by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3ProgressByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3ProgressByProcessIdAsyncWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV3ProgressByProcessId'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3';
        $request = $this->productsV3ProgressByProcessIdRequest($processUuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV3ProgressByProcessId'
     *
     * @param  string $processUuid search for a product data delivery result by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3ProgressByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV3ProgressByProcessIdRequest($processUuid, string $contentType = self::contentTypes['productsV3ProgressByProcessId'][0])
    {

        // verify the required parameter 'processUuid' is set
        if ($processUuid === null || (is_array($processUuid) && count($processUuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $processUuid when calling productsV3ProgressByProcessId'
            );
        }


        $resourcePath = '/v3/products/update-tasks/{processUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($processUuid !== null) {
            $resourcePath = str_replace(
                '{' . 'processUuid' . '}',
                ObjectSerializer::toPathValue($processUuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV3SucceededByProcessId
     *
     * List succeeded products of a product data delivery
     *
     * @param  string $processUuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3SucceededByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3
     */
    public function productsV3SucceededByProcessId($processUuid, string $contentType = self::contentTypes['productsV3SucceededByProcessId'][0])
    {
        list($response) = $this->productsV3SucceededByProcessIdWithHttpInfo($processUuid, $contentType);
        return $response;
    }

    /**
     * Operation productsV3SucceededByProcessIdWithHttpInfo
     *
     * List succeeded products of a product data delivery
     *
     * @param  string $processUuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3SucceededByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV3SucceededByProcessIdWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV3SucceededByProcessId'][0])
    {
        $request = $this->productsV3SucceededByProcessIdRequest($processUuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV3SucceededByProcessIdAsync
     *
     * List succeeded products of a product data delivery
     *
     * @param  string $processUuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3SucceededByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3SucceededByProcessIdAsync($processUuid, string $contentType = self::contentTypes['productsV3SucceededByProcessId'][0])
    {
        return $this->productsV3SucceededByProcessIdAsyncWithHttpInfo($processUuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV3SucceededByProcessIdAsyncWithHttpInfo
     *
     * List succeeded products of a product data delivery
     *
     * @param  string $processUuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3SucceededByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3SucceededByProcessIdAsyncWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV3SucceededByProcessId'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3';
        $request = $this->productsV3SucceededByProcessIdRequest($processUuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV3SucceededByProcessId'
     *
     * @param  string $processUuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3SucceededByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV3SucceededByProcessIdRequest($processUuid, string $contentType = self::contentTypes['productsV3SucceededByProcessId'][0])
    {

        // verify the required parameter 'processUuid' is set
        if ($processUuid === null || (is_array($processUuid) && count($processUuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $processUuid when calling productsV3SucceededByProcessId'
            );
        }


        $resourcePath = '/v3/products/update-tasks/{processUuid}/succeeded';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($processUuid !== null) {
            $resourcePath = str_replace(
                '{' . 'processUuid' . '}',
                ObjectSerializer::toPathValue($processUuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV3UnchangedByProcessId
     *
     * List unchanged products of a product data delivery
     *
     * @param  string $processUuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3UnchangedByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3
     */
    public function productsV3UnchangedByProcessId($processUuid, string $contentType = self::contentTypes['productsV3UnchangedByProcessId'][0])
    {
        list($response) = $this->productsV3UnchangedByProcessIdWithHttpInfo($processUuid, $contentType);
        return $response;
    }

    /**
     * Operation productsV3UnchangedByProcessIdWithHttpInfo
     *
     * List unchanged products of a product data delivery
     *
     * @param  string $processUuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3UnchangedByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV3UnchangedByProcessIdWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV3UnchangedByProcessId'][0])
    {
        $request = $this->productsV3UnchangedByProcessIdRequest($processUuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV3UnchangedByProcessIdAsync
     *
     * List unchanged products of a product data delivery
     *
     * @param  string $processUuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3UnchangedByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3UnchangedByProcessIdAsync($processUuid, string $contentType = self::contentTypes['productsV3UnchangedByProcessId'][0])
    {
        return $this->productsV3UnchangedByProcessIdAsyncWithHttpInfo($processUuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV3UnchangedByProcessIdAsyncWithHttpInfo
     *
     * List unchanged products of a product data delivery
     *
     * @param  string $processUuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3UnchangedByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3UnchangedByProcessIdAsyncWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV3UnchangedByProcessId'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV3';
        $request = $this->productsV3UnchangedByProcessIdRequest($processUuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV3UnchangedByProcessId'
     *
     * @param  string $processUuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3UnchangedByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV3UnchangedByProcessIdRequest($processUuid, string $contentType = self::contentTypes['productsV3UnchangedByProcessId'][0])
    {

        // verify the required parameter 'processUuid' is set
        if ($processUuid === null || (is_array($processUuid) && count($processUuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $processUuid when calling productsV3UnchangedByProcessId'
            );
        }


        $resourcePath = '/v3/products/update-tasks/{processUuid}/unchanged';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($processUuid !== null) {
            $resourcePath = str_replace(
                '{' . 'processUuid' . '}',
                ObjectSerializer::toPathValue($processUuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV3UpdateActiveStatus
     *
     * Update active status
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ActiveStatusListRequestProductsV3|null $activeStatusListRequestProductsV3 activeStatusListRequestProductsV3 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3UpdateActiveStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3
     */
    public function productsV3UpdateActiveStatus($xRequestTimestamp = null, $activeStatusListRequestProductsV3 = null, string $contentType = self::contentTypes['productsV3UpdateActiveStatus'][0])
    {
        list($response) = $this->productsV3UpdateActiveStatusWithHttpInfo($xRequestTimestamp, $activeStatusListRequestProductsV3, $contentType);
        return $response;
    }

    /**
     * Operation productsV3UpdateActiveStatusWithHttpInfo
     *
     * Update active status
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ActiveStatusListRequestProductsV3|null $activeStatusListRequestProductsV3 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3UpdateActiveStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV3UpdateActiveStatusWithHttpInfo($xRequestTimestamp = null, $activeStatusListRequestProductsV3 = null, string $contentType = self::contentTypes['productsV3UpdateActiveStatus'][0])
    {
        $request = $this->productsV3UpdateActiveStatusRequest($xRequestTimestamp, $activeStatusListRequestProductsV3, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV3UpdateActiveStatusAsync
     *
     * Update active status
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ActiveStatusListRequestProductsV3|null $activeStatusListRequestProductsV3 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3UpdateActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3UpdateActiveStatusAsync($xRequestTimestamp = null, $activeStatusListRequestProductsV3 = null, string $contentType = self::contentTypes['productsV3UpdateActiveStatus'][0])
    {
        return $this->productsV3UpdateActiveStatusAsyncWithHttpInfo($xRequestTimestamp, $activeStatusListRequestProductsV3, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV3UpdateActiveStatusAsyncWithHttpInfo
     *
     * Update active status
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ActiveStatusListRequestProductsV3|null $activeStatusListRequestProductsV3 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3UpdateActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3UpdateActiveStatusAsyncWithHttpInfo($xRequestTimestamp = null, $activeStatusListRequestProductsV3 = null, string $contentType = self::contentTypes['productsV3UpdateActiveStatus'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3';
        $request = $this->productsV3UpdateActiveStatusRequest($xRequestTimestamp, $activeStatusListRequestProductsV3, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV3UpdateActiveStatus'
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ActiveStatusListRequestProductsV3|null $activeStatusListRequestProductsV3 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3UpdateActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV3UpdateActiveStatusRequest($xRequestTimestamp = null, $activeStatusListRequestProductsV3 = null, string $contentType = self::contentTypes['productsV3UpdateActiveStatus'][0])
    {




        $resourcePath = '/v3/products/active-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($xRequestTimestamp !== null) {
            $headerParams['X-Request-Timestamp'] = ObjectSerializer::toHeaderValue($xRequestTimestamp);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($activeStatusListRequestProductsV3)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($activeStatusListRequestProductsV3));
            } else {
                $httpBody = $activeStatusListRequestProductsV3;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV3UpdateProductVariationPrices
     *
     * Update product variation prices
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\SkuPricingProductsV3[]|null $skuPricingProductsV3 skuPricingProductsV3 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3UpdateProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3
     */
    public function productsV3UpdateProductVariationPrices($xRequestTimestamp = null, $skuPricingProductsV3 = null, string $contentType = self::contentTypes['productsV3UpdateProductVariationPrices'][0])
    {
        list($response) = $this->productsV3UpdateProductVariationPricesWithHttpInfo($xRequestTimestamp, $skuPricingProductsV3, $contentType);
        return $response;
    }

    /**
     * Operation productsV3UpdateProductVariationPricesWithHttpInfo
     *
     * Update product variation prices
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\SkuPricingProductsV3[]|null $skuPricingProductsV3 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3UpdateProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV3UpdateProductVariationPricesWithHttpInfo($xRequestTimestamp = null, $skuPricingProductsV3 = null, string $contentType = self::contentTypes['productsV3UpdateProductVariationPrices'][0])
    {
        $request = $this->productsV3UpdateProductVariationPricesRequest($xRequestTimestamp, $skuPricingProductsV3, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV3UpdateProductVariationPricesAsync
     *
     * Update product variation prices
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\SkuPricingProductsV3[]|null $skuPricingProductsV3 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3UpdateProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3UpdateProductVariationPricesAsync($xRequestTimestamp = null, $skuPricingProductsV3 = null, string $contentType = self::contentTypes['productsV3UpdateProductVariationPrices'][0])
    {
        return $this->productsV3UpdateProductVariationPricesAsyncWithHttpInfo($xRequestTimestamp, $skuPricingProductsV3, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV3UpdateProductVariationPricesAsyncWithHttpInfo
     *
     * Update product variation prices
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\SkuPricingProductsV3[]|null $skuPricingProductsV3 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3UpdateProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV3UpdateProductVariationPricesAsyncWithHttpInfo($xRequestTimestamp = null, $skuPricingProductsV3 = null, string $contentType = self::contentTypes['productsV3UpdateProductVariationPrices'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV3';
        $request = $this->productsV3UpdateProductVariationPricesRequest($xRequestTimestamp, $skuPricingProductsV3, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV3UpdateProductVariationPrices'
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\SkuPricingProductsV3[]|null $skuPricingProductsV3 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV3UpdateProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV3UpdateProductVariationPricesRequest($xRequestTimestamp = null, $skuPricingProductsV3 = null, string $contentType = self::contentTypes['productsV3UpdateProductVariationPrices'][0])
    {




        $resourcePath = '/v3/products/prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($xRequestTimestamp !== null) {
            $headerParams['X-Request-Timestamp'] = ObjectSerializer::toHeaderValue($xRequestTimestamp);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($skuPricingProductsV3)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($skuPricingProductsV3));
            } else {
                $httpBody = $skuPricingProductsV3;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
