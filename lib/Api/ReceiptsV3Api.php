<?php
/**
 * ReceiptsV3Api
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client\Otto
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * OTTO Market API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Otto\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\Otto\ApiException;
use OpenAPI\Client\Otto\Configuration;
use OpenAPI\Client\Otto\HeaderSelector;
use OpenAPI\Client\Otto\ObjectSerializer;

/**
 * ReceiptsV3Api Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client\Otto
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ReceiptsV3Api
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'receiptsV3GetReceiptPdfUsingGET3' => [
            'application/json',
        ],
        'receiptsV3GetReceiptUsingGET5' => [
            'application/json',
        ],
        'receiptsV3GetReceiptsUsingGET5' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation receiptsV3GetReceiptPdfUsingGET3
     *
     * Get the PDF document of a specific receipt
     *
     * @param  string $receiptNumber ReceiptNumber (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['receiptsV3GetReceiptPdfUsingGET3'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function receiptsV3GetReceiptPdfUsingGET3($receiptNumber, string $contentType = self::contentTypes['receiptsV3GetReceiptPdfUsingGET3'][0])
    {
        $this->receiptsV3GetReceiptPdfUsingGET3WithHttpInfo($receiptNumber, $contentType);
    }

    /**
     * Operation receiptsV3GetReceiptPdfUsingGET3WithHttpInfo
     *
     * Get the PDF document of a specific receipt
     *
     * @param  string $receiptNumber ReceiptNumber (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['receiptsV3GetReceiptPdfUsingGET3'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function receiptsV3GetReceiptPdfUsingGET3WithHttpInfo($receiptNumber, string $contentType = self::contentTypes['receiptsV3GetReceiptPdfUsingGET3'][0])
    {
        $request = $this->receiptsV3GetReceiptPdfUsingGET3Request($receiptNumber, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation receiptsV3GetReceiptPdfUsingGET3Async
     *
     * Get the PDF document of a specific receipt
     *
     * @param  string $receiptNumber ReceiptNumber (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['receiptsV3GetReceiptPdfUsingGET3'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function receiptsV3GetReceiptPdfUsingGET3Async($receiptNumber, string $contentType = self::contentTypes['receiptsV3GetReceiptPdfUsingGET3'][0])
    {
        return $this->receiptsV3GetReceiptPdfUsingGET3AsyncWithHttpInfo($receiptNumber, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation receiptsV3GetReceiptPdfUsingGET3AsyncWithHttpInfo
     *
     * Get the PDF document of a specific receipt
     *
     * @param  string $receiptNumber ReceiptNumber (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['receiptsV3GetReceiptPdfUsingGET3'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function receiptsV3GetReceiptPdfUsingGET3AsyncWithHttpInfo($receiptNumber, string $contentType = self::contentTypes['receiptsV3GetReceiptPdfUsingGET3'][0])
    {
        $returnType = '';
        $request = $this->receiptsV3GetReceiptPdfUsingGET3Request($receiptNumber, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'receiptsV3GetReceiptPdfUsingGET3'
     *
     * @param  string $receiptNumber ReceiptNumber (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['receiptsV3GetReceiptPdfUsingGET3'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function receiptsV3GetReceiptPdfUsingGET3Request($receiptNumber, string $contentType = self::contentTypes['receiptsV3GetReceiptPdfUsingGET3'][0])
    {

        // verify the required parameter 'receiptNumber' is set
        if ($receiptNumber === null || (is_array($receiptNumber) && count($receiptNumber) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $receiptNumber when calling receiptsV3GetReceiptPdfUsingGET3'
            );
        }


        $resourcePath = '/v3/receipts/{receiptNumber}.pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($receiptNumber !== null) {
            $resourcePath = str_replace(
                '{' . 'receiptNumber' . '}',
                ObjectSerializer::toPathValue($receiptNumber),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation receiptsV3GetReceiptUsingGET5
     *
     * Get the JSON object of a specific receipt
     *
     * @param  string $receiptNumber ReceiptNumber (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['receiptsV3GetReceiptUsingGET5'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ReceiptReceiptsV3
     */
    public function receiptsV3GetReceiptUsingGET5($receiptNumber, string $contentType = self::contentTypes['receiptsV3GetReceiptUsingGET5'][0])
    {
        list($response) = $this->receiptsV3GetReceiptUsingGET5WithHttpInfo($receiptNumber, $contentType);
        return $response;
    }

    /**
     * Operation receiptsV3GetReceiptUsingGET5WithHttpInfo
     *
     * Get the JSON object of a specific receipt
     *
     * @param  string $receiptNumber ReceiptNumber (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['receiptsV3GetReceiptUsingGET5'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ReceiptReceiptsV3, HTTP status code, HTTP response headers (array of strings)
     */
    public function receiptsV3GetReceiptUsingGET5WithHttpInfo($receiptNumber, string $contentType = self::contentTypes['receiptsV3GetReceiptUsingGET5'][0])
    {
        $request = $this->receiptsV3GetReceiptUsingGET5Request($receiptNumber, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ReceiptReceiptsV3' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ReceiptReceiptsV3' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ReceiptReceiptsV3', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ReceiptReceiptsV3';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ReceiptReceiptsV3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation receiptsV3GetReceiptUsingGET5Async
     *
     * Get the JSON object of a specific receipt
     *
     * @param  string $receiptNumber ReceiptNumber (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['receiptsV3GetReceiptUsingGET5'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function receiptsV3GetReceiptUsingGET5Async($receiptNumber, string $contentType = self::contentTypes['receiptsV3GetReceiptUsingGET5'][0])
    {
        return $this->receiptsV3GetReceiptUsingGET5AsyncWithHttpInfo($receiptNumber, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation receiptsV3GetReceiptUsingGET5AsyncWithHttpInfo
     *
     * Get the JSON object of a specific receipt
     *
     * @param  string $receiptNumber ReceiptNumber (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['receiptsV3GetReceiptUsingGET5'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function receiptsV3GetReceiptUsingGET5AsyncWithHttpInfo($receiptNumber, string $contentType = self::contentTypes['receiptsV3GetReceiptUsingGET5'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ReceiptReceiptsV3';
        $request = $this->receiptsV3GetReceiptUsingGET5Request($receiptNumber, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'receiptsV3GetReceiptUsingGET5'
     *
     * @param  string $receiptNumber ReceiptNumber (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['receiptsV3GetReceiptUsingGET5'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function receiptsV3GetReceiptUsingGET5Request($receiptNumber, string $contentType = self::contentTypes['receiptsV3GetReceiptUsingGET5'][0])
    {

        // verify the required parameter 'receiptNumber' is set
        if ($receiptNumber === null || (is_array($receiptNumber) && count($receiptNumber) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $receiptNumber when calling receiptsV3GetReceiptUsingGET5'
            );
        }


        $resourcePath = '/v3/receipts/{receiptNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($receiptNumber !== null) {
            $resourcePath = str_replace(
                '{' . 'receiptNumber' . '}',
                ObjectSerializer::toPathValue($receiptNumber),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation receiptsV3GetReceiptsUsingGET5
     *
     * Get receipts as list of JSON objects
     *
     * @param  int|null $limit Page size to limit the number of receipts returned in the response (optional, default to 128)
     * @param  int|null $page Page number to fetch. This parameter is required to fetch data for specific page number. &lt;/br&gt;This field is deprecated, please use &#39;next&#39; parameter (optional, default to 1) (deprecated)
     * @param  string[]|null $receiptTypes Search for receipts filtered by multiple receipt types.  &lt;/br&gt;PURCHASE - A purchase receipt (also known as an invoice) records the prices charged to the customer at the time of sale. The receipt contains information per order, partner and shipment. It is generated when items are shipped to the customer, so there may be more than one receipt per order. Shipping costs are charged only once per partner and per order, and are billed with first purchase receipt of this partner order. Surcharges imposed by payment provider on the customer for using special payment conditions are not included in the OTTO Market receipts.  &lt;/br&gt;REFUND - We distinguish between different types of reimbursement documents. A refund receipt documents a credit note issued to a customer for a refund. This document is currently created when returns are accepted.  In very rare cases, refund receipts may also be created during the cancellation process to reimburse shipping costs for full returns.  Previous partial refunds will be taken into account.  &lt;/br&gt; PARTIAL_REFUND -  We distinguish different types of reimbursement documents. A partial refund receipt documents a credit note issued to a customer without return.  As a partner, you might offer a customer a partial refund if there is a legitimate complaint to avoid a return.  &lt;/br&gt;If no receiptType is provided, receipts  of all existing receiptTypes will be returned.  &lt;b&gt;Please for your own interest, hand over all receipt types you are interested in using the list parameter receiptTypes, so that OTTO Market could add new receipt types without side effects for your own processes. Using this option you can decide by your own when to incorporate new receipt types in your own processes.   Please do not use the possibility of calls without specifying the receiptTypes anymore.&lt;/b&gt; (optional)
     * @param  \DateTime|null $from Only receipts with creation date newer or equal than the date specified (yyy-mm-dd in UTC) will be returned. (optional)
     * @param  \DateTime|null $to Only receipts with creation date older or equal than the date specified (yyy-mm-dd in UTC) will be returned. (optional)
     * @param  string|null $salesOrderId Search for receipts filtered by sales order Id (optional)
     * @param  string|null $next Cursor for paging requests. If a next cursor is provided, the only other request parameter being considered is &#39;limit&#39;  Note: Only the cursor string is required - not the whole link (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['receiptsV3GetReceiptsUsingGET5'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ReceiptsListReceiptsV3
     */
    public function receiptsV3GetReceiptsUsingGET5($limit = 128, $page = 1, $receiptTypes = null, $from = null, $to = null, $salesOrderId = null, $next = null, string $contentType = self::contentTypes['receiptsV3GetReceiptsUsingGET5'][0])
    {
        list($response) = $this->receiptsV3GetReceiptsUsingGET5WithHttpInfo($limit, $page, $receiptTypes, $from, $to, $salesOrderId, $next, $contentType);
        return $response;
    }

    /**
     * Operation receiptsV3GetReceiptsUsingGET5WithHttpInfo
     *
     * Get receipts as list of JSON objects
     *
     * @param  int|null $limit Page size to limit the number of receipts returned in the response (optional, default to 128)
     * @param  int|null $page Page number to fetch. This parameter is required to fetch data for specific page number. &lt;/br&gt;This field is deprecated, please use &#39;next&#39; parameter (optional, default to 1) (deprecated)
     * @param  string[]|null $receiptTypes Search for receipts filtered by multiple receipt types.  &lt;/br&gt;PURCHASE - A purchase receipt (also known as an invoice) records the prices charged to the customer at the time of sale. The receipt contains information per order, partner and shipment. It is generated when items are shipped to the customer, so there may be more than one receipt per order. Shipping costs are charged only once per partner and per order, and are billed with first purchase receipt of this partner order. Surcharges imposed by payment provider on the customer for using special payment conditions are not included in the OTTO Market receipts.  &lt;/br&gt;REFUND - We distinguish between different types of reimbursement documents. A refund receipt documents a credit note issued to a customer for a refund. This document is currently created when returns are accepted.  In very rare cases, refund receipts may also be created during the cancellation process to reimburse shipping costs for full returns.  Previous partial refunds will be taken into account.  &lt;/br&gt; PARTIAL_REFUND -  We distinguish different types of reimbursement documents. A partial refund receipt documents a credit note issued to a customer without return.  As a partner, you might offer a customer a partial refund if there is a legitimate complaint to avoid a return.  &lt;/br&gt;If no receiptType is provided, receipts  of all existing receiptTypes will be returned.  &lt;b&gt;Please for your own interest, hand over all receipt types you are interested in using the list parameter receiptTypes, so that OTTO Market could add new receipt types without side effects for your own processes. Using this option you can decide by your own when to incorporate new receipt types in your own processes.   Please do not use the possibility of calls without specifying the receiptTypes anymore.&lt;/b&gt; (optional)
     * @param  \DateTime|null $from Only receipts with creation date newer or equal than the date specified (yyy-mm-dd in UTC) will be returned. (optional)
     * @param  \DateTime|null $to Only receipts with creation date older or equal than the date specified (yyy-mm-dd in UTC) will be returned. (optional)
     * @param  string|null $salesOrderId Search for receipts filtered by sales order Id (optional)
     * @param  string|null $next Cursor for paging requests. If a next cursor is provided, the only other request parameter being considered is &#39;limit&#39;  Note: Only the cursor string is required - not the whole link (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['receiptsV3GetReceiptsUsingGET5'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ReceiptsListReceiptsV3, HTTP status code, HTTP response headers (array of strings)
     */
    public function receiptsV3GetReceiptsUsingGET5WithHttpInfo($limit = 128, $page = 1, $receiptTypes = null, $from = null, $to = null, $salesOrderId = null, $next = null, string $contentType = self::contentTypes['receiptsV3GetReceiptsUsingGET5'][0])
    {
        $request = $this->receiptsV3GetReceiptsUsingGET5Request($limit, $page, $receiptTypes, $from, $to, $salesOrderId, $next, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ReceiptsListReceiptsV3' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ReceiptsListReceiptsV3' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ReceiptsListReceiptsV3', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ReceiptsListReceiptsV3';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ReceiptsListReceiptsV3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation receiptsV3GetReceiptsUsingGET5Async
     *
     * Get receipts as list of JSON objects
     *
     * @param  int|null $limit Page size to limit the number of receipts returned in the response (optional, default to 128)
     * @param  int|null $page Page number to fetch. This parameter is required to fetch data for specific page number. &lt;/br&gt;This field is deprecated, please use &#39;next&#39; parameter (optional, default to 1) (deprecated)
     * @param  string[]|null $receiptTypes Search for receipts filtered by multiple receipt types.  &lt;/br&gt;PURCHASE - A purchase receipt (also known as an invoice) records the prices charged to the customer at the time of sale. The receipt contains information per order, partner and shipment. It is generated when items are shipped to the customer, so there may be more than one receipt per order. Shipping costs are charged only once per partner and per order, and are billed with first purchase receipt of this partner order. Surcharges imposed by payment provider on the customer for using special payment conditions are not included in the OTTO Market receipts.  &lt;/br&gt;REFUND - We distinguish between different types of reimbursement documents. A refund receipt documents a credit note issued to a customer for a refund. This document is currently created when returns are accepted.  In very rare cases, refund receipts may also be created during the cancellation process to reimburse shipping costs for full returns.  Previous partial refunds will be taken into account.  &lt;/br&gt; PARTIAL_REFUND -  We distinguish different types of reimbursement documents. A partial refund receipt documents a credit note issued to a customer without return.  As a partner, you might offer a customer a partial refund if there is a legitimate complaint to avoid a return.  &lt;/br&gt;If no receiptType is provided, receipts  of all existing receiptTypes will be returned.  &lt;b&gt;Please for your own interest, hand over all receipt types you are interested in using the list parameter receiptTypes, so that OTTO Market could add new receipt types without side effects for your own processes. Using this option you can decide by your own when to incorporate new receipt types in your own processes.   Please do not use the possibility of calls without specifying the receiptTypes anymore.&lt;/b&gt; (optional)
     * @param  \DateTime|null $from Only receipts with creation date newer or equal than the date specified (yyy-mm-dd in UTC) will be returned. (optional)
     * @param  \DateTime|null $to Only receipts with creation date older or equal than the date specified (yyy-mm-dd in UTC) will be returned. (optional)
     * @param  string|null $salesOrderId Search for receipts filtered by sales order Id (optional)
     * @param  string|null $next Cursor for paging requests. If a next cursor is provided, the only other request parameter being considered is &#39;limit&#39;  Note: Only the cursor string is required - not the whole link (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['receiptsV3GetReceiptsUsingGET5'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function receiptsV3GetReceiptsUsingGET5Async($limit = 128, $page = 1, $receiptTypes = null, $from = null, $to = null, $salesOrderId = null, $next = null, string $contentType = self::contentTypes['receiptsV3GetReceiptsUsingGET5'][0])
    {
        return $this->receiptsV3GetReceiptsUsingGET5AsyncWithHttpInfo($limit, $page, $receiptTypes, $from, $to, $salesOrderId, $next, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation receiptsV3GetReceiptsUsingGET5AsyncWithHttpInfo
     *
     * Get receipts as list of JSON objects
     *
     * @param  int|null $limit Page size to limit the number of receipts returned in the response (optional, default to 128)
     * @param  int|null $page Page number to fetch. This parameter is required to fetch data for specific page number. &lt;/br&gt;This field is deprecated, please use &#39;next&#39; parameter (optional, default to 1) (deprecated)
     * @param  string[]|null $receiptTypes Search for receipts filtered by multiple receipt types.  &lt;/br&gt;PURCHASE - A purchase receipt (also known as an invoice) records the prices charged to the customer at the time of sale. The receipt contains information per order, partner and shipment. It is generated when items are shipped to the customer, so there may be more than one receipt per order. Shipping costs are charged only once per partner and per order, and are billed with first purchase receipt of this partner order. Surcharges imposed by payment provider on the customer for using special payment conditions are not included in the OTTO Market receipts.  &lt;/br&gt;REFUND - We distinguish between different types of reimbursement documents. A refund receipt documents a credit note issued to a customer for a refund. This document is currently created when returns are accepted.  In very rare cases, refund receipts may also be created during the cancellation process to reimburse shipping costs for full returns.  Previous partial refunds will be taken into account.  &lt;/br&gt; PARTIAL_REFUND -  We distinguish different types of reimbursement documents. A partial refund receipt documents a credit note issued to a customer without return.  As a partner, you might offer a customer a partial refund if there is a legitimate complaint to avoid a return.  &lt;/br&gt;If no receiptType is provided, receipts  of all existing receiptTypes will be returned.  &lt;b&gt;Please for your own interest, hand over all receipt types you are interested in using the list parameter receiptTypes, so that OTTO Market could add new receipt types without side effects for your own processes. Using this option you can decide by your own when to incorporate new receipt types in your own processes.   Please do not use the possibility of calls without specifying the receiptTypes anymore.&lt;/b&gt; (optional)
     * @param  \DateTime|null $from Only receipts with creation date newer or equal than the date specified (yyy-mm-dd in UTC) will be returned. (optional)
     * @param  \DateTime|null $to Only receipts with creation date older or equal than the date specified (yyy-mm-dd in UTC) will be returned. (optional)
     * @param  string|null $salesOrderId Search for receipts filtered by sales order Id (optional)
     * @param  string|null $next Cursor for paging requests. If a next cursor is provided, the only other request parameter being considered is &#39;limit&#39;  Note: Only the cursor string is required - not the whole link (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['receiptsV3GetReceiptsUsingGET5'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function receiptsV3GetReceiptsUsingGET5AsyncWithHttpInfo($limit = 128, $page = 1, $receiptTypes = null, $from = null, $to = null, $salesOrderId = null, $next = null, string $contentType = self::contentTypes['receiptsV3GetReceiptsUsingGET5'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ReceiptsListReceiptsV3';
        $request = $this->receiptsV3GetReceiptsUsingGET5Request($limit, $page, $receiptTypes, $from, $to, $salesOrderId, $next, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'receiptsV3GetReceiptsUsingGET5'
     *
     * @param  int|null $limit Page size to limit the number of receipts returned in the response (optional, default to 128)
     * @param  int|null $page Page number to fetch. This parameter is required to fetch data for specific page number. &lt;/br&gt;This field is deprecated, please use &#39;next&#39; parameter (optional, default to 1) (deprecated)
     * @param  string[]|null $receiptTypes Search for receipts filtered by multiple receipt types.  &lt;/br&gt;PURCHASE - A purchase receipt (also known as an invoice) records the prices charged to the customer at the time of sale. The receipt contains information per order, partner and shipment. It is generated when items are shipped to the customer, so there may be more than one receipt per order. Shipping costs are charged only once per partner and per order, and are billed with first purchase receipt of this partner order. Surcharges imposed by payment provider on the customer for using special payment conditions are not included in the OTTO Market receipts.  &lt;/br&gt;REFUND - We distinguish between different types of reimbursement documents. A refund receipt documents a credit note issued to a customer for a refund. This document is currently created when returns are accepted.  In very rare cases, refund receipts may also be created during the cancellation process to reimburse shipping costs for full returns.  Previous partial refunds will be taken into account.  &lt;/br&gt; PARTIAL_REFUND -  We distinguish different types of reimbursement documents. A partial refund receipt documents a credit note issued to a customer without return.  As a partner, you might offer a customer a partial refund if there is a legitimate complaint to avoid a return.  &lt;/br&gt;If no receiptType is provided, receipts  of all existing receiptTypes will be returned.  &lt;b&gt;Please for your own interest, hand over all receipt types you are interested in using the list parameter receiptTypes, so that OTTO Market could add new receipt types without side effects for your own processes. Using this option you can decide by your own when to incorporate new receipt types in your own processes.   Please do not use the possibility of calls without specifying the receiptTypes anymore.&lt;/b&gt; (optional)
     * @param  \DateTime|null $from Only receipts with creation date newer or equal than the date specified (yyy-mm-dd in UTC) will be returned. (optional)
     * @param  \DateTime|null $to Only receipts with creation date older or equal than the date specified (yyy-mm-dd in UTC) will be returned. (optional)
     * @param  string|null $salesOrderId Search for receipts filtered by sales order Id (optional)
     * @param  string|null $next Cursor for paging requests. If a next cursor is provided, the only other request parameter being considered is &#39;limit&#39;  Note: Only the cursor string is required - not the whole link (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['receiptsV3GetReceiptsUsingGET5'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function receiptsV3GetReceiptsUsingGET5Request($limit = 128, $page = 1, $receiptTypes = null, $from = null, $to = null, $salesOrderId = null, $next = null, string $contentType = self::contentTypes['receiptsV3GetReceiptsUsingGET5'][0])
    {

        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling ReceiptsV3Api.receiptsV3GetReceiptsUsingGET5, must be bigger than or equal to 1.');
        }








        $resourcePath = '/v3/receipts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $receiptTypes,
            'receiptTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $from,
            'from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $to,
            'to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $salesOrderId,
            'salesOrderId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next,
            'next', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
