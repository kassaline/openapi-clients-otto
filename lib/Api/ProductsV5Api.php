<?php
/**
 * ProductsV5Api
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client\Otto
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * OTTO Market API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Otto\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\Otto\ApiException;
use OpenAPI\Client\Otto\Configuration;
use OpenAPI\Client\Otto\HeaderSelector;
use OpenAPI\Client\Otto\ObjectSerializer;

/**
 * ProductsV5Api Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client\Otto
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ProductsV5Api
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'productsV5SandboxOnlyCreateOrUpdateProductVariations' => [
            'application/json',
        ],
        'productsV5SandboxOnlyFailedByProcessId' => [
            'application/json',
        ],
        'productsV5SandboxOnlyGetActiveStatus' => [
            'application/json',
        ],
        'productsV5SandboxOnlyGetBrands' => [
            'application/json',
        ],
        'productsV5SandboxOnlyGetCategoryGroups' => [
            'application/json',
        ],
        'productsV5SandboxOnlyGetContentChanges' => [
            'application/json',
        ],
        'productsV5SandboxOnlyGetContentChanges2' => [
            'application/json',
        ],
        'productsV5SandboxOnlyGetMarketPlaceStatus' => [
            'application/json',
        ],
        'productsV5SandboxOnlyGetMarketPlaceStatusList' => [
            'application/json',
        ],
        'productsV5SandboxOnlyGetPartnerProducts' => [
            'application/json',
        ],
        'productsV5SandboxOnlyGetProductVariation' => [
            'application/json',
        ],
        'productsV5SandboxOnlyGetProductVariationPrice' => [
            'application/json',
        ],
        'productsV5SandboxOnlyGetProductVariationPrices' => [
            'application/json',
        ],
        'productsV5SandboxOnlyGetVariationActiveStatus' => [
            'application/json',
        ],
        'productsV5SandboxOnlyProgressByProcessId' => [
            'application/json',
        ],
        'productsV5SandboxOnlySucceededByProcessId' => [
            'application/json',
        ],
        'productsV5SandboxOnlyUnchangedByProcessId' => [
            'application/json',
        ],
        'productsV5SandboxOnlyUpdateActiveStatus' => [
            'application/json',
        ],
        'productsV5SandboxOnlyUpdateProductVariationPrices' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation productsV5SandboxOnlyCreateOrUpdateProductVariations
     *
     * Create or update product variations
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ProductVariationProductsV5SandboxOnly[]|null $productVariationProductsV5SandboxOnly productVariationProductsV5SandboxOnly (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyCreateOrUpdateProductVariations'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly
     */
    public function productsV5SandboxOnlyCreateOrUpdateProductVariations($xRequestTimestamp = null, $productVariationProductsV5SandboxOnly = null, string $contentType = self::contentTypes['productsV5SandboxOnlyCreateOrUpdateProductVariations'][0])
    {
        list($response) = $this->productsV5SandboxOnlyCreateOrUpdateProductVariationsWithHttpInfo($xRequestTimestamp, $productVariationProductsV5SandboxOnly, $contentType);
        return $response;
    }

    /**
     * Operation productsV5SandboxOnlyCreateOrUpdateProductVariationsWithHttpInfo
     *
     * Create or update product variations
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ProductVariationProductsV5SandboxOnly[]|null $productVariationProductsV5SandboxOnly (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyCreateOrUpdateProductVariations'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5SandboxOnlyCreateOrUpdateProductVariationsWithHttpInfo($xRequestTimestamp = null, $productVariationProductsV5SandboxOnly = null, string $contentType = self::contentTypes['productsV5SandboxOnlyCreateOrUpdateProductVariations'][0])
    {
        $request = $this->productsV5SandboxOnlyCreateOrUpdateProductVariationsRequest($xRequestTimestamp, $productVariationProductsV5SandboxOnly, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5SandboxOnlyCreateOrUpdateProductVariationsAsync
     *
     * Create or update product variations
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ProductVariationProductsV5SandboxOnly[]|null $productVariationProductsV5SandboxOnly (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyCreateOrUpdateProductVariations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyCreateOrUpdateProductVariationsAsync($xRequestTimestamp = null, $productVariationProductsV5SandboxOnly = null, string $contentType = self::contentTypes['productsV5SandboxOnlyCreateOrUpdateProductVariations'][0])
    {
        return $this->productsV5SandboxOnlyCreateOrUpdateProductVariationsAsyncWithHttpInfo($xRequestTimestamp, $productVariationProductsV5SandboxOnly, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5SandboxOnlyCreateOrUpdateProductVariationsAsyncWithHttpInfo
     *
     * Create or update product variations
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ProductVariationProductsV5SandboxOnly[]|null $productVariationProductsV5SandboxOnly (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyCreateOrUpdateProductVariations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyCreateOrUpdateProductVariationsAsyncWithHttpInfo($xRequestTimestamp = null, $productVariationProductsV5SandboxOnly = null, string $contentType = self::contentTypes['productsV5SandboxOnlyCreateOrUpdateProductVariations'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly';
        $request = $this->productsV5SandboxOnlyCreateOrUpdateProductVariationsRequest($xRequestTimestamp, $productVariationProductsV5SandboxOnly, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5SandboxOnlyCreateOrUpdateProductVariations'
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ProductVariationProductsV5SandboxOnly[]|null $productVariationProductsV5SandboxOnly (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyCreateOrUpdateProductVariations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV5SandboxOnlyCreateOrUpdateProductVariationsRequest($xRequestTimestamp = null, $productVariationProductsV5SandboxOnly = null, string $contentType = self::contentTypes['productsV5SandboxOnlyCreateOrUpdateProductVariations'][0])
    {




        $resourcePath = '/v5/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($xRequestTimestamp !== null) {
            $headerParams['X-Request-Timestamp'] = ObjectSerializer::toHeaderValue($xRequestTimestamp);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($productVariationProductsV5SandboxOnly)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($productVariationProductsV5SandboxOnly));
            } else {
                $httpBody = $productVariationProductsV5SandboxOnly;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5SandboxOnlyFailedByProcessId
     *
     * List failed products of a product data delivery
     *
     * @param  string $processUuid search for the failed products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyFailedByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly
     */
    public function productsV5SandboxOnlyFailedByProcessId($processUuid, string $contentType = self::contentTypes['productsV5SandboxOnlyFailedByProcessId'][0])
    {
        list($response) = $this->productsV5SandboxOnlyFailedByProcessIdWithHttpInfo($processUuid, $contentType);
        return $response;
    }

    /**
     * Operation productsV5SandboxOnlyFailedByProcessIdWithHttpInfo
     *
     * List failed products of a product data delivery
     *
     * @param  string $processUuid search for the failed products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyFailedByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5SandboxOnlyFailedByProcessIdWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV5SandboxOnlyFailedByProcessId'][0])
    {
        $request = $this->productsV5SandboxOnlyFailedByProcessIdRequest($processUuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5SandboxOnlyFailedByProcessIdAsync
     *
     * List failed products of a product data delivery
     *
     * @param  string $processUuid search for the failed products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyFailedByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyFailedByProcessIdAsync($processUuid, string $contentType = self::contentTypes['productsV5SandboxOnlyFailedByProcessId'][0])
    {
        return $this->productsV5SandboxOnlyFailedByProcessIdAsyncWithHttpInfo($processUuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5SandboxOnlyFailedByProcessIdAsyncWithHttpInfo
     *
     * List failed products of a product data delivery
     *
     * @param  string $processUuid search for the failed products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyFailedByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyFailedByProcessIdAsyncWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV5SandboxOnlyFailedByProcessId'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly';
        $request = $this->productsV5SandboxOnlyFailedByProcessIdRequest($processUuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5SandboxOnlyFailedByProcessId'
     *
     * @param  string $processUuid search for the failed products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyFailedByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV5SandboxOnlyFailedByProcessIdRequest($processUuid, string $contentType = self::contentTypes['productsV5SandboxOnlyFailedByProcessId'][0])
    {

        // verify the required parameter 'processUuid' is set
        if ($processUuid === null || (is_array($processUuid) && count($processUuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $processUuid when calling productsV5SandboxOnlyFailedByProcessId'
            );
        }


        $resourcePath = '/v5/products/update-tasks/{processUuid}/failed';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($processUuid !== null) {
            $resourcePath = str_replace(
                '{' . 'processUuid' . '}',
                ObjectSerializer::toPathValue($processUuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5SandboxOnlyGetActiveStatus
     *
     * Read active status
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brand ID value (optional)
     * @param  int|null $page page (optional)
     * @param  int|null $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetActiveStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV5SandboxOnly
     */
    public function productsV5SandboxOnlyGetActiveStatus($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetActiveStatus'][0])
    {
        list($response) = $this->productsV5SandboxOnlyGetActiveStatusWithHttpInfo($sku, $productReference, $category, $brandId, $page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation productsV5SandboxOnlyGetActiveStatusWithHttpInfo
     *
     * Read active status
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brand ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetActiveStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV5SandboxOnly, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5SandboxOnlyGetActiveStatusWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetActiveStatus'][0])
    {
        $request = $this->productsV5SandboxOnlyGetActiveStatusRequest($sku, $productReference, $category, $brandId, $page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV5SandboxOnly' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV5SandboxOnly' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV5SandboxOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV5SandboxOnly';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV5SandboxOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5SandboxOnlyGetActiveStatusAsync
     *
     * Read active status
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brand ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetActiveStatusAsync($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetActiveStatus'][0])
    {
        return $this->productsV5SandboxOnlyGetActiveStatusAsyncWithHttpInfo($sku, $productReference, $category, $brandId, $page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5SandboxOnlyGetActiveStatusAsyncWithHttpInfo
     *
     * Read active status
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brand ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetActiveStatusAsyncWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetActiveStatus'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV5SandboxOnly';
        $request = $this->productsV5SandboxOnlyGetActiveStatusRequest($sku, $productReference, $category, $brandId, $page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5SandboxOnlyGetActiveStatus'
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brand ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV5SandboxOnlyGetActiveStatusRequest($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetActiveStatus'][0])
    {








        $resourcePath = '/v5/products/active-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $productReference,
            'productReference', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brandId,
            'brandId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5SandboxOnlyGetBrands
     *
     * List of allowed brands
     *
     * @param  string|null $ifMatch The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string|null $ifNoneMatch The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string|null $ifModifiedSince The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#39;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#39;s data is avoided if that data has not changed. (optional)
     * @param  string|null $ifUnmodifiedSince The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#39;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int|null $page page (optional)
     * @param  int|null $limit limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetBrands'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\BrandListResponseProductsV5SandboxOnly
     */
    public function productsV5SandboxOnlyGetBrands($ifMatch = null, $ifNoneMatch = null, $ifModifiedSince = null, $ifUnmodifiedSince = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetBrands'][0])
    {
        list($response) = $this->productsV5SandboxOnlyGetBrandsWithHttpInfo($ifMatch, $ifNoneMatch, $ifModifiedSince, $ifUnmodifiedSince, $page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation productsV5SandboxOnlyGetBrandsWithHttpInfo
     *
     * List of allowed brands
     *
     * @param  string|null $ifMatch The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string|null $ifNoneMatch The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string|null $ifModifiedSince The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#39;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#39;s data is avoided if that data has not changed. (optional)
     * @param  string|null $ifUnmodifiedSince The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#39;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetBrands'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\BrandListResponseProductsV5SandboxOnly, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5SandboxOnlyGetBrandsWithHttpInfo($ifMatch = null, $ifNoneMatch = null, $ifModifiedSince = null, $ifUnmodifiedSince = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetBrands'][0])
    {
        $request = $this->productsV5SandboxOnlyGetBrandsRequest($ifMatch, $ifNoneMatch, $ifModifiedSince, $ifUnmodifiedSince, $page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\BrandListResponseProductsV5SandboxOnly' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\BrandListResponseProductsV5SandboxOnly' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\BrandListResponseProductsV5SandboxOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\BrandListResponseProductsV5SandboxOnly';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\BrandListResponseProductsV5SandboxOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5SandboxOnlyGetBrandsAsync
     *
     * List of allowed brands
     *
     * @param  string|null $ifMatch The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string|null $ifNoneMatch The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string|null $ifModifiedSince The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#39;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#39;s data is avoided if that data has not changed. (optional)
     * @param  string|null $ifUnmodifiedSince The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#39;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetBrands'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetBrandsAsync($ifMatch = null, $ifNoneMatch = null, $ifModifiedSince = null, $ifUnmodifiedSince = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetBrands'][0])
    {
        return $this->productsV5SandboxOnlyGetBrandsAsyncWithHttpInfo($ifMatch, $ifNoneMatch, $ifModifiedSince, $ifUnmodifiedSince, $page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5SandboxOnlyGetBrandsAsyncWithHttpInfo
     *
     * List of allowed brands
     *
     * @param  string|null $ifMatch The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string|null $ifNoneMatch The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string|null $ifModifiedSince The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#39;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#39;s data is avoided if that data has not changed. (optional)
     * @param  string|null $ifUnmodifiedSince The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#39;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetBrands'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetBrandsAsyncWithHttpInfo($ifMatch = null, $ifNoneMatch = null, $ifModifiedSince = null, $ifUnmodifiedSince = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetBrands'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\BrandListResponseProductsV5SandboxOnly';
        $request = $this->productsV5SandboxOnlyGetBrandsRequest($ifMatch, $ifNoneMatch, $ifModifiedSince, $ifUnmodifiedSince, $page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5SandboxOnlyGetBrands'
     *
     * @param  string|null $ifMatch The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string|null $ifNoneMatch The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string|null $ifModifiedSince The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#39;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#39;s data is avoided if that data has not changed. (optional)
     * @param  string|null $ifUnmodifiedSince The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#39;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetBrands'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV5SandboxOnlyGetBrandsRequest($ifMatch = null, $ifNoneMatch = null, $ifModifiedSince = null, $ifUnmodifiedSince = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetBrands'][0])
    {








        $resourcePath = '/v5/products/brands';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($ifMatch !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($ifMatch);
        }
        // header params
        if ($ifNoneMatch !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($ifNoneMatch);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }
        // header params
        if ($ifUnmodifiedSince !== null) {
            $headerParams['If-Unmodified-Since'] = ObjectSerializer::toHeaderValue($ifUnmodifiedSince);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5SandboxOnlyGetCategoryGroups
     *
     * Read product categories
     *
     * @param  int|null $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int|null $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string|null $category read a single category (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetCategoryGroups'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\CategoryGroupsProductsV5SandboxOnly
     */
    public function productsV5SandboxOnlyGetCategoryGroups($page = null, $limit = null, $category = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetCategoryGroups'][0])
    {
        list($response) = $this->productsV5SandboxOnlyGetCategoryGroupsWithHttpInfo($page, $limit, $category, $contentType);
        return $response;
    }

    /**
     * Operation productsV5SandboxOnlyGetCategoryGroupsWithHttpInfo
     *
     * Read product categories
     *
     * @param  int|null $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int|null $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string|null $category read a single category (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetCategoryGroups'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\CategoryGroupsProductsV5SandboxOnly, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5SandboxOnlyGetCategoryGroupsWithHttpInfo($page = null, $limit = null, $category = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetCategoryGroups'][0])
    {
        $request = $this->productsV5SandboxOnlyGetCategoryGroupsRequest($page, $limit, $category, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\CategoryGroupsProductsV5SandboxOnly' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\CategoryGroupsProductsV5SandboxOnly' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\CategoryGroupsProductsV5SandboxOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\CategoryGroupsProductsV5SandboxOnly';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\CategoryGroupsProductsV5SandboxOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5SandboxOnlyGetCategoryGroupsAsync
     *
     * Read product categories
     *
     * @param  int|null $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int|null $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string|null $category read a single category (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetCategoryGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetCategoryGroupsAsync($page = null, $limit = null, $category = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetCategoryGroups'][0])
    {
        return $this->productsV5SandboxOnlyGetCategoryGroupsAsyncWithHttpInfo($page, $limit, $category, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5SandboxOnlyGetCategoryGroupsAsyncWithHttpInfo
     *
     * Read product categories
     *
     * @param  int|null $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int|null $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string|null $category read a single category (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetCategoryGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetCategoryGroupsAsyncWithHttpInfo($page = null, $limit = null, $category = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetCategoryGroups'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\CategoryGroupsProductsV5SandboxOnly';
        $request = $this->productsV5SandboxOnlyGetCategoryGroupsRequest($page, $limit, $category, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5SandboxOnlyGetCategoryGroups'
     *
     * @param  int|null $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int|null $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string|null $category read a single category (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetCategoryGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV5SandboxOnlyGetCategoryGroupsRequest($page = null, $limit = null, $category = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetCategoryGroups'][0])
    {





        $resourcePath = '/v5/products/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5SandboxOnlyGetContentChanges
     *
     * Read content changes for a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime|null $fromDate search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page page (optional)
     * @param  int|null $limit proposed limit for the number of entries per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetContentChanges'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV5SandboxOnly
     */
    public function productsV5SandboxOnlyGetContentChanges($sku, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetContentChanges'][0])
    {
        list($response) = $this->productsV5SandboxOnlyGetContentChangesWithHttpInfo($sku, $fromDate, $page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation productsV5SandboxOnlyGetContentChangesWithHttpInfo
     *
     * Read content changes for a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime|null $fromDate search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of entries per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetContentChanges'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV5SandboxOnly, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5SandboxOnlyGetContentChangesWithHttpInfo($sku, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetContentChanges'][0])
    {
        $request = $this->productsV5SandboxOnlyGetContentChangesRequest($sku, $fromDate, $page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV5SandboxOnly' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV5SandboxOnly' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV5SandboxOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV5SandboxOnly';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV5SandboxOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5SandboxOnlyGetContentChangesAsync
     *
     * Read content changes for a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime|null $fromDate search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of entries per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetContentChanges'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetContentChangesAsync($sku, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetContentChanges'][0])
    {
        return $this->productsV5SandboxOnlyGetContentChangesAsyncWithHttpInfo($sku, $fromDate, $page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5SandboxOnlyGetContentChangesAsyncWithHttpInfo
     *
     * Read content changes for a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime|null $fromDate search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of entries per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetContentChanges'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetContentChangesAsyncWithHttpInfo($sku, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetContentChanges'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV5SandboxOnly';
        $request = $this->productsV5SandboxOnlyGetContentChangesRequest($sku, $fromDate, $page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5SandboxOnlyGetContentChanges'
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime|null $fromDate search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of entries per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetContentChanges'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV5SandboxOnlyGetContentChangesRequest($sku, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetContentChanges'][0])
    {

        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV5SandboxOnlyGetContentChanges'
            );
        }





        $resourcePath = '/v5/products/{sku}/content-changes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fromDate,
            'fromDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5SandboxOnlyGetContentChanges2
     *
     * Read content changes within time period
     *
     * @param  string[]|null $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime|null $fromDate search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page page (optional)
     * @param  int|null $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetContentChanges2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV5SandboxOnly
     */
    public function productsV5SandboxOnlyGetContentChanges2($sku = null, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetContentChanges2'][0])
    {
        list($response) = $this->productsV5SandboxOnlyGetContentChanges2WithHttpInfo($sku, $fromDate, $page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation productsV5SandboxOnlyGetContentChanges2WithHttpInfo
     *
     * Read content changes within time period
     *
     * @param  string[]|null $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime|null $fromDate search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetContentChanges2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV5SandboxOnly, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5SandboxOnlyGetContentChanges2WithHttpInfo($sku = null, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetContentChanges2'][0])
    {
        $request = $this->productsV5SandboxOnlyGetContentChanges2Request($sku, $fromDate, $page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV5SandboxOnly' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV5SandboxOnly' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV5SandboxOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV5SandboxOnly';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV5SandboxOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5SandboxOnlyGetContentChanges2Async
     *
     * Read content changes within time period
     *
     * @param  string[]|null $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime|null $fromDate search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetContentChanges2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetContentChanges2Async($sku = null, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetContentChanges2'][0])
    {
        return $this->productsV5SandboxOnlyGetContentChanges2AsyncWithHttpInfo($sku, $fromDate, $page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5SandboxOnlyGetContentChanges2AsyncWithHttpInfo
     *
     * Read content changes within time period
     *
     * @param  string[]|null $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime|null $fromDate search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetContentChanges2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetContentChanges2AsyncWithHttpInfo($sku = null, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetContentChanges2'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV5SandboxOnly';
        $request = $this->productsV5SandboxOnlyGetContentChanges2Request($sku, $fromDate, $page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5SandboxOnlyGetContentChanges2'
     *
     * @param  string[]|null $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime|null $fromDate search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetContentChanges2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV5SandboxOnlyGetContentChanges2Request($sku = null, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetContentChanges2'][0])
    {






        $resourcePath = '/v5/products/content-changes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fromDate,
            'fromDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5SandboxOnlyGetMarketPlaceStatus
     *
     * Read marketplace status for a single product variation
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetMarketPlaceStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV5SandboxOnly
     */
    public function productsV5SandboxOnlyGetMarketPlaceStatus($sku, string $contentType = self::contentTypes['productsV5SandboxOnlyGetMarketPlaceStatus'][0])
    {
        list($response) = $this->productsV5SandboxOnlyGetMarketPlaceStatusWithHttpInfo($sku, $contentType);
        return $response;
    }

    /**
     * Operation productsV5SandboxOnlyGetMarketPlaceStatusWithHttpInfo
     *
     * Read marketplace status for a single product variation
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetMarketPlaceStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV5SandboxOnly, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5SandboxOnlyGetMarketPlaceStatusWithHttpInfo($sku, string $contentType = self::contentTypes['productsV5SandboxOnlyGetMarketPlaceStatus'][0])
    {
        $request = $this->productsV5SandboxOnlyGetMarketPlaceStatusRequest($sku, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV5SandboxOnly' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV5SandboxOnly' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV5SandboxOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV5SandboxOnly';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV5SandboxOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5SandboxOnlyGetMarketPlaceStatusAsync
     *
     * Read marketplace status for a single product variation
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetMarketPlaceStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetMarketPlaceStatusAsync($sku, string $contentType = self::contentTypes['productsV5SandboxOnlyGetMarketPlaceStatus'][0])
    {
        return $this->productsV5SandboxOnlyGetMarketPlaceStatusAsyncWithHttpInfo($sku, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5SandboxOnlyGetMarketPlaceStatusAsyncWithHttpInfo
     *
     * Read marketplace status for a single product variation
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetMarketPlaceStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetMarketPlaceStatusAsyncWithHttpInfo($sku, string $contentType = self::contentTypes['productsV5SandboxOnlyGetMarketPlaceStatus'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV5SandboxOnly';
        $request = $this->productsV5SandboxOnlyGetMarketPlaceStatusRequest($sku, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5SandboxOnlyGetMarketPlaceStatus'
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetMarketPlaceStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV5SandboxOnlyGetMarketPlaceStatusRequest($sku, string $contentType = self::contentTypes['productsV5SandboxOnlyGetMarketPlaceStatus'][0])
    {

        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV5SandboxOnlyGetMarketPlaceStatus'
            );
        }


        $resourcePath = '/v5/products/{sku}/marketplace-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5SandboxOnlyGetMarketPlaceStatusList
     *
     * Read marketplace status of product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string|null $category search marketplace status by the category value of the related product variations (optional)
     * @param  string|null $brandId search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime|null $fromDate search marketplace status for a time range starting with the given date (in ISO8601, like &#39;2021-10-09T07:52:19.820Z&#39; or &#39;2021-10-09T07:52:19.820+01:00&#39;) (optional)
     * @param  int|null $page page to load (optional)
     * @param  int|null $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[]|null $marketPlaceStatus only include items that match any of the provided status (optional)
     * @param  string|null $sortOrder Define the sort order of the resulting entries. Available values are &#39;desc&#39; for &#39;newest lastModified first&#39; and &#39;asc&#39; for &#39;oldest lastModified first&#39; - default is &#39;desc&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetMarketPlaceStatusList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV5SandboxOnly
     */
    public function productsV5SandboxOnlyGetMarketPlaceStatusList($sku = null, $productReference = null, $category = null, $brandId = null, $fromDate = null, $page = null, $limit = null, $marketPlaceStatus = null, $sortOrder = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetMarketPlaceStatusList'][0])
    {
        list($response) = $this->productsV5SandboxOnlyGetMarketPlaceStatusListWithHttpInfo($sku, $productReference, $category, $brandId, $fromDate, $page, $limit, $marketPlaceStatus, $sortOrder, $contentType);
        return $response;
    }

    /**
     * Operation productsV5SandboxOnlyGetMarketPlaceStatusListWithHttpInfo
     *
     * Read marketplace status of product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string|null $category search marketplace status by the category value of the related product variations (optional)
     * @param  string|null $brandId search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime|null $fromDate search marketplace status for a time range starting with the given date (in ISO8601, like &#39;2021-10-09T07:52:19.820Z&#39; or &#39;2021-10-09T07:52:19.820+01:00&#39;) (optional)
     * @param  int|null $page page to load (optional)
     * @param  int|null $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[]|null $marketPlaceStatus only include items that match any of the provided status (optional)
     * @param  string|null $sortOrder Define the sort order of the resulting entries. Available values are &#39;desc&#39; for &#39;newest lastModified first&#39; and &#39;asc&#39; for &#39;oldest lastModified first&#39; - default is &#39;desc&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetMarketPlaceStatusList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV5SandboxOnly, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5SandboxOnlyGetMarketPlaceStatusListWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $fromDate = null, $page = null, $limit = null, $marketPlaceStatus = null, $sortOrder = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetMarketPlaceStatusList'][0])
    {
        $request = $this->productsV5SandboxOnlyGetMarketPlaceStatusListRequest($sku, $productReference, $category, $brandId, $fromDate, $page, $limit, $marketPlaceStatus, $sortOrder, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV5SandboxOnly' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV5SandboxOnly' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV5SandboxOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV5SandboxOnly';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV5SandboxOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5SandboxOnlyGetMarketPlaceStatusListAsync
     *
     * Read marketplace status of product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string|null $category search marketplace status by the category value of the related product variations (optional)
     * @param  string|null $brandId search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime|null $fromDate search marketplace status for a time range starting with the given date (in ISO8601, like &#39;2021-10-09T07:52:19.820Z&#39; or &#39;2021-10-09T07:52:19.820+01:00&#39;) (optional)
     * @param  int|null $page page to load (optional)
     * @param  int|null $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[]|null $marketPlaceStatus only include items that match any of the provided status (optional)
     * @param  string|null $sortOrder Define the sort order of the resulting entries. Available values are &#39;desc&#39; for &#39;newest lastModified first&#39; and &#39;asc&#39; for &#39;oldest lastModified first&#39; - default is &#39;desc&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetMarketPlaceStatusList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetMarketPlaceStatusListAsync($sku = null, $productReference = null, $category = null, $brandId = null, $fromDate = null, $page = null, $limit = null, $marketPlaceStatus = null, $sortOrder = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetMarketPlaceStatusList'][0])
    {
        return $this->productsV5SandboxOnlyGetMarketPlaceStatusListAsyncWithHttpInfo($sku, $productReference, $category, $brandId, $fromDate, $page, $limit, $marketPlaceStatus, $sortOrder, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5SandboxOnlyGetMarketPlaceStatusListAsyncWithHttpInfo
     *
     * Read marketplace status of product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string|null $category search marketplace status by the category value of the related product variations (optional)
     * @param  string|null $brandId search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime|null $fromDate search marketplace status for a time range starting with the given date (in ISO8601, like &#39;2021-10-09T07:52:19.820Z&#39; or &#39;2021-10-09T07:52:19.820+01:00&#39;) (optional)
     * @param  int|null $page page to load (optional)
     * @param  int|null $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[]|null $marketPlaceStatus only include items that match any of the provided status (optional)
     * @param  string|null $sortOrder Define the sort order of the resulting entries. Available values are &#39;desc&#39; for &#39;newest lastModified first&#39; and &#39;asc&#39; for &#39;oldest lastModified first&#39; - default is &#39;desc&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetMarketPlaceStatusList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetMarketPlaceStatusListAsyncWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $fromDate = null, $page = null, $limit = null, $marketPlaceStatus = null, $sortOrder = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetMarketPlaceStatusList'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV5SandboxOnly';
        $request = $this->productsV5SandboxOnlyGetMarketPlaceStatusListRequest($sku, $productReference, $category, $brandId, $fromDate, $page, $limit, $marketPlaceStatus, $sortOrder, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5SandboxOnlyGetMarketPlaceStatusList'
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string|null $category search marketplace status by the category value of the related product variations (optional)
     * @param  string|null $brandId search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime|null $fromDate search marketplace status for a time range starting with the given date (in ISO8601, like &#39;2021-10-09T07:52:19.820Z&#39; or &#39;2021-10-09T07:52:19.820+01:00&#39;) (optional)
     * @param  int|null $page page to load (optional)
     * @param  int|null $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[]|null $marketPlaceStatus only include items that match any of the provided status (optional)
     * @param  string|null $sortOrder Define the sort order of the resulting entries. Available values are &#39;desc&#39; for &#39;newest lastModified first&#39; and &#39;asc&#39; for &#39;oldest lastModified first&#39; - default is &#39;desc&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetMarketPlaceStatusList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV5SandboxOnlyGetMarketPlaceStatusListRequest($sku = null, $productReference = null, $category = null, $brandId = null, $fromDate = null, $page = null, $limit = null, $marketPlaceStatus = null, $sortOrder = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetMarketPlaceStatusList'][0])
    {











        $resourcePath = '/v5/products/marketplace-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $productReference,
            'productReference', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brandId,
            'brandId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fromDate,
            'fromDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $marketPlaceStatus,
            'marketPlaceStatus', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sortOrder,
            'sort-order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5SandboxOnlyGetPartnerProducts
     *
     * Read product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brandId value (optional)
     * @param  int|null $page page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetPartnerProducts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV5SandboxOnly
     */
    public function productsV5SandboxOnlyGetPartnerProducts($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetPartnerProducts'][0])
    {
        list($response) = $this->productsV5SandboxOnlyGetPartnerProductsWithHttpInfo($sku, $productReference, $category, $brandId, $page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation productsV5SandboxOnlyGetPartnerProductsWithHttpInfo
     *
     * Read product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brandId value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetPartnerProducts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV5SandboxOnly, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5SandboxOnlyGetPartnerProductsWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetPartnerProducts'][0])
    {
        $request = $this->productsV5SandboxOnlyGetPartnerProductsRequest($sku, $productReference, $category, $brandId, $page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV5SandboxOnly' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV5SandboxOnly' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV5SandboxOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV5SandboxOnly';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV5SandboxOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5SandboxOnlyGetPartnerProductsAsync
     *
     * Read product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brandId value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetPartnerProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetPartnerProductsAsync($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetPartnerProducts'][0])
    {
        return $this->productsV5SandboxOnlyGetPartnerProductsAsyncWithHttpInfo($sku, $productReference, $category, $brandId, $page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5SandboxOnlyGetPartnerProductsAsyncWithHttpInfo
     *
     * Read product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brandId value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetPartnerProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetPartnerProductsAsyncWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetPartnerProducts'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV5SandboxOnly';
        $request = $this->productsV5SandboxOnlyGetPartnerProductsRequest($sku, $productReference, $category, $brandId, $page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5SandboxOnlyGetPartnerProducts'
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brandId value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetPartnerProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV5SandboxOnlyGetPartnerProductsRequest($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetPartnerProducts'][0])
    {








        $resourcePath = '/v5/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $productReference,
            'productReference', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brandId,
            'brandId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5SandboxOnlyGetProductVariation
     *
     * Read a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetProductVariation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductVariationProductsV5SandboxOnly
     */
    public function productsV5SandboxOnlyGetProductVariation($sku, string $contentType = self::contentTypes['productsV5SandboxOnlyGetProductVariation'][0])
    {
        list($response) = $this->productsV5SandboxOnlyGetProductVariationWithHttpInfo($sku, $contentType);
        return $response;
    }

    /**
     * Operation productsV5SandboxOnlyGetProductVariationWithHttpInfo
     *
     * Read a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetProductVariation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductVariationProductsV5SandboxOnly, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5SandboxOnlyGetProductVariationWithHttpInfo($sku, string $contentType = self::contentTypes['productsV5SandboxOnlyGetProductVariation'][0])
    {
        $request = $this->productsV5SandboxOnlyGetProductVariationRequest($sku, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ProductVariationProductsV5SandboxOnly' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductVariationProductsV5SandboxOnly' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductVariationProductsV5SandboxOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductVariationProductsV5SandboxOnly';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductVariationProductsV5SandboxOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5SandboxOnlyGetProductVariationAsync
     *
     * Read a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetProductVariation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetProductVariationAsync($sku, string $contentType = self::contentTypes['productsV5SandboxOnlyGetProductVariation'][0])
    {
        return $this->productsV5SandboxOnlyGetProductVariationAsyncWithHttpInfo($sku, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5SandboxOnlyGetProductVariationAsyncWithHttpInfo
     *
     * Read a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetProductVariation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetProductVariationAsyncWithHttpInfo($sku, string $contentType = self::contentTypes['productsV5SandboxOnlyGetProductVariation'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductVariationProductsV5SandboxOnly';
        $request = $this->productsV5SandboxOnlyGetProductVariationRequest($sku, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5SandboxOnlyGetProductVariation'
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetProductVariation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV5SandboxOnlyGetProductVariationRequest($sku, string $contentType = self::contentTypes['productsV5SandboxOnlyGetProductVariation'][0])
    {

        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV5SandboxOnlyGetProductVariation'
            );
        }


        $resourcePath = '/v5/products/{sku}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5SandboxOnlyGetProductVariationPrice
     *
     * Read a single product variation price
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetProductVariationPrice'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\SkuPricingProductsV5SandboxOnly
     */
    public function productsV5SandboxOnlyGetProductVariationPrice($sku, string $contentType = self::contentTypes['productsV5SandboxOnlyGetProductVariationPrice'][0])
    {
        list($response) = $this->productsV5SandboxOnlyGetProductVariationPriceWithHttpInfo($sku, $contentType);
        return $response;
    }

    /**
     * Operation productsV5SandboxOnlyGetProductVariationPriceWithHttpInfo
     *
     * Read a single product variation price
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetProductVariationPrice'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\SkuPricingProductsV5SandboxOnly, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5SandboxOnlyGetProductVariationPriceWithHttpInfo($sku, string $contentType = self::contentTypes['productsV5SandboxOnlyGetProductVariationPrice'][0])
    {
        $request = $this->productsV5SandboxOnlyGetProductVariationPriceRequest($sku, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\SkuPricingProductsV5SandboxOnly' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\SkuPricingProductsV5SandboxOnly' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\SkuPricingProductsV5SandboxOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\SkuPricingProductsV5SandboxOnly';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\SkuPricingProductsV5SandboxOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5SandboxOnlyGetProductVariationPriceAsync
     *
     * Read a single product variation price
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetProductVariationPrice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetProductVariationPriceAsync($sku, string $contentType = self::contentTypes['productsV5SandboxOnlyGetProductVariationPrice'][0])
    {
        return $this->productsV5SandboxOnlyGetProductVariationPriceAsyncWithHttpInfo($sku, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5SandboxOnlyGetProductVariationPriceAsyncWithHttpInfo
     *
     * Read a single product variation price
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetProductVariationPrice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetProductVariationPriceAsyncWithHttpInfo($sku, string $contentType = self::contentTypes['productsV5SandboxOnlyGetProductVariationPrice'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\SkuPricingProductsV5SandboxOnly';
        $request = $this->productsV5SandboxOnlyGetProductVariationPriceRequest($sku, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5SandboxOnlyGetProductVariationPrice'
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetProductVariationPrice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV5SandboxOnlyGetProductVariationPriceRequest($sku, string $contentType = self::contentTypes['productsV5SandboxOnlyGetProductVariationPrice'][0])
    {

        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV5SandboxOnlyGetProductVariationPrice'
            );
        }


        $resourcePath = '/v5/products/{sku}/prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5SandboxOnlyGetProductVariationPrices
     *
     * Read product variations prices
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their ID value (optional)
     * @param  int|null $page page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\PriceApiResultProductsV5SandboxOnly
     */
    public function productsV5SandboxOnlyGetProductVariationPrices($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetProductVariationPrices'][0])
    {
        list($response) = $this->productsV5SandboxOnlyGetProductVariationPricesWithHttpInfo($sku, $productReference, $category, $brandId, $page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation productsV5SandboxOnlyGetProductVariationPricesWithHttpInfo
     *
     * Read product variations prices
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\PriceApiResultProductsV5SandboxOnly, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5SandboxOnlyGetProductVariationPricesWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetProductVariationPrices'][0])
    {
        $request = $this->productsV5SandboxOnlyGetProductVariationPricesRequest($sku, $productReference, $category, $brandId, $page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\PriceApiResultProductsV5SandboxOnly' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\PriceApiResultProductsV5SandboxOnly' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\PriceApiResultProductsV5SandboxOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\PriceApiResultProductsV5SandboxOnly';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\PriceApiResultProductsV5SandboxOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5SandboxOnlyGetProductVariationPricesAsync
     *
     * Read product variations prices
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetProductVariationPricesAsync($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetProductVariationPrices'][0])
    {
        return $this->productsV5SandboxOnlyGetProductVariationPricesAsyncWithHttpInfo($sku, $productReference, $category, $brandId, $page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5SandboxOnlyGetProductVariationPricesAsyncWithHttpInfo
     *
     * Read product variations prices
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetProductVariationPricesAsyncWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetProductVariationPrices'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\PriceApiResultProductsV5SandboxOnly';
        $request = $this->productsV5SandboxOnlyGetProductVariationPricesRequest($sku, $productReference, $category, $brandId, $page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5SandboxOnlyGetProductVariationPrices'
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV5SandboxOnlyGetProductVariationPricesRequest($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV5SandboxOnlyGetProductVariationPrices'][0])
    {








        $resourcePath = '/v5/products/prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $productReference,
            'productReference', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brandId,
            'brandId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5SandboxOnlyGetVariationActiveStatus
     *
     * Read the active status of a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetVariationActiveStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ActiveStatusProductsV5SandboxOnly
     */
    public function productsV5SandboxOnlyGetVariationActiveStatus($sku, string $contentType = self::contentTypes['productsV5SandboxOnlyGetVariationActiveStatus'][0])
    {
        list($response) = $this->productsV5SandboxOnlyGetVariationActiveStatusWithHttpInfo($sku, $contentType);
        return $response;
    }

    /**
     * Operation productsV5SandboxOnlyGetVariationActiveStatusWithHttpInfo
     *
     * Read the active status of a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetVariationActiveStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ActiveStatusProductsV5SandboxOnly, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5SandboxOnlyGetVariationActiveStatusWithHttpInfo($sku, string $contentType = self::contentTypes['productsV5SandboxOnlyGetVariationActiveStatus'][0])
    {
        $request = $this->productsV5SandboxOnlyGetVariationActiveStatusRequest($sku, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ActiveStatusProductsV5SandboxOnly' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ActiveStatusProductsV5SandboxOnly' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ActiveStatusProductsV5SandboxOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ActiveStatusProductsV5SandboxOnly';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ActiveStatusProductsV5SandboxOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5SandboxOnlyGetVariationActiveStatusAsync
     *
     * Read the active status of a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetVariationActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetVariationActiveStatusAsync($sku, string $contentType = self::contentTypes['productsV5SandboxOnlyGetVariationActiveStatus'][0])
    {
        return $this->productsV5SandboxOnlyGetVariationActiveStatusAsyncWithHttpInfo($sku, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5SandboxOnlyGetVariationActiveStatusAsyncWithHttpInfo
     *
     * Read the active status of a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetVariationActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyGetVariationActiveStatusAsyncWithHttpInfo($sku, string $contentType = self::contentTypes['productsV5SandboxOnlyGetVariationActiveStatus'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ActiveStatusProductsV5SandboxOnly';
        $request = $this->productsV5SandboxOnlyGetVariationActiveStatusRequest($sku, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5SandboxOnlyGetVariationActiveStatus'
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyGetVariationActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV5SandboxOnlyGetVariationActiveStatusRequest($sku, string $contentType = self::contentTypes['productsV5SandboxOnlyGetVariationActiveStatus'][0])
    {

        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV5SandboxOnlyGetVariationActiveStatus'
            );
        }


        $resourcePath = '/v5/products/{sku}/active-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5SandboxOnlyProgressByProcessId
     *
     * Request the results of a product data delivery
     *
     * @param  string $processUuid search for a product data delivery result by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyProgressByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly
     */
    public function productsV5SandboxOnlyProgressByProcessId($processUuid, string $contentType = self::contentTypes['productsV5SandboxOnlyProgressByProcessId'][0])
    {
        list($response) = $this->productsV5SandboxOnlyProgressByProcessIdWithHttpInfo($processUuid, $contentType);
        return $response;
    }

    /**
     * Operation productsV5SandboxOnlyProgressByProcessIdWithHttpInfo
     *
     * Request the results of a product data delivery
     *
     * @param  string $processUuid search for a product data delivery result by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyProgressByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5SandboxOnlyProgressByProcessIdWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV5SandboxOnlyProgressByProcessId'][0])
    {
        $request = $this->productsV5SandboxOnlyProgressByProcessIdRequest($processUuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5SandboxOnlyProgressByProcessIdAsync
     *
     * Request the results of a product data delivery
     *
     * @param  string $processUuid search for a product data delivery result by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyProgressByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyProgressByProcessIdAsync($processUuid, string $contentType = self::contentTypes['productsV5SandboxOnlyProgressByProcessId'][0])
    {
        return $this->productsV5SandboxOnlyProgressByProcessIdAsyncWithHttpInfo($processUuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5SandboxOnlyProgressByProcessIdAsyncWithHttpInfo
     *
     * Request the results of a product data delivery
     *
     * @param  string $processUuid search for a product data delivery result by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyProgressByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyProgressByProcessIdAsyncWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV5SandboxOnlyProgressByProcessId'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly';
        $request = $this->productsV5SandboxOnlyProgressByProcessIdRequest($processUuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5SandboxOnlyProgressByProcessId'
     *
     * @param  string $processUuid search for a product data delivery result by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyProgressByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV5SandboxOnlyProgressByProcessIdRequest($processUuid, string $contentType = self::contentTypes['productsV5SandboxOnlyProgressByProcessId'][0])
    {

        // verify the required parameter 'processUuid' is set
        if ($processUuid === null || (is_array($processUuid) && count($processUuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $processUuid when calling productsV5SandboxOnlyProgressByProcessId'
            );
        }


        $resourcePath = '/v5/products/update-tasks/{processUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($processUuid !== null) {
            $resourcePath = str_replace(
                '{' . 'processUuid' . '}',
                ObjectSerializer::toPathValue($processUuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5SandboxOnlySucceededByProcessId
     *
     * List succeeded products of a product data delivery
     *
     * @param  string $processUuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlySucceededByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly
     */
    public function productsV5SandboxOnlySucceededByProcessId($processUuid, string $contentType = self::contentTypes['productsV5SandboxOnlySucceededByProcessId'][0])
    {
        list($response) = $this->productsV5SandboxOnlySucceededByProcessIdWithHttpInfo($processUuid, $contentType);
        return $response;
    }

    /**
     * Operation productsV5SandboxOnlySucceededByProcessIdWithHttpInfo
     *
     * List succeeded products of a product data delivery
     *
     * @param  string $processUuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlySucceededByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5SandboxOnlySucceededByProcessIdWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV5SandboxOnlySucceededByProcessId'][0])
    {
        $request = $this->productsV5SandboxOnlySucceededByProcessIdRequest($processUuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5SandboxOnlySucceededByProcessIdAsync
     *
     * List succeeded products of a product data delivery
     *
     * @param  string $processUuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlySucceededByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlySucceededByProcessIdAsync($processUuid, string $contentType = self::contentTypes['productsV5SandboxOnlySucceededByProcessId'][0])
    {
        return $this->productsV5SandboxOnlySucceededByProcessIdAsyncWithHttpInfo($processUuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5SandboxOnlySucceededByProcessIdAsyncWithHttpInfo
     *
     * List succeeded products of a product data delivery
     *
     * @param  string $processUuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlySucceededByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlySucceededByProcessIdAsyncWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV5SandboxOnlySucceededByProcessId'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly';
        $request = $this->productsV5SandboxOnlySucceededByProcessIdRequest($processUuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5SandboxOnlySucceededByProcessId'
     *
     * @param  string $processUuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlySucceededByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV5SandboxOnlySucceededByProcessIdRequest($processUuid, string $contentType = self::contentTypes['productsV5SandboxOnlySucceededByProcessId'][0])
    {

        // verify the required parameter 'processUuid' is set
        if ($processUuid === null || (is_array($processUuid) && count($processUuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $processUuid when calling productsV5SandboxOnlySucceededByProcessId'
            );
        }


        $resourcePath = '/v5/products/update-tasks/{processUuid}/succeeded';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($processUuid !== null) {
            $resourcePath = str_replace(
                '{' . 'processUuid' . '}',
                ObjectSerializer::toPathValue($processUuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5SandboxOnlyUnchangedByProcessId
     *
     * List unchanged products of a product data delivery
     *
     * @param  string $processUuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyUnchangedByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly
     */
    public function productsV5SandboxOnlyUnchangedByProcessId($processUuid, string $contentType = self::contentTypes['productsV5SandboxOnlyUnchangedByProcessId'][0])
    {
        list($response) = $this->productsV5SandboxOnlyUnchangedByProcessIdWithHttpInfo($processUuid, $contentType);
        return $response;
    }

    /**
     * Operation productsV5SandboxOnlyUnchangedByProcessIdWithHttpInfo
     *
     * List unchanged products of a product data delivery
     *
     * @param  string $processUuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyUnchangedByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5SandboxOnlyUnchangedByProcessIdWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV5SandboxOnlyUnchangedByProcessId'][0])
    {
        $request = $this->productsV5SandboxOnlyUnchangedByProcessIdRequest($processUuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5SandboxOnlyUnchangedByProcessIdAsync
     *
     * List unchanged products of a product data delivery
     *
     * @param  string $processUuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyUnchangedByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyUnchangedByProcessIdAsync($processUuid, string $contentType = self::contentTypes['productsV5SandboxOnlyUnchangedByProcessId'][0])
    {
        return $this->productsV5SandboxOnlyUnchangedByProcessIdAsyncWithHttpInfo($processUuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5SandboxOnlyUnchangedByProcessIdAsyncWithHttpInfo
     *
     * List unchanged products of a product data delivery
     *
     * @param  string $processUuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyUnchangedByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyUnchangedByProcessIdAsyncWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV5SandboxOnlyUnchangedByProcessId'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV5SandboxOnly';
        $request = $this->productsV5SandboxOnlyUnchangedByProcessIdRequest($processUuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5SandboxOnlyUnchangedByProcessId'
     *
     * @param  string $processUuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyUnchangedByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV5SandboxOnlyUnchangedByProcessIdRequest($processUuid, string $contentType = self::contentTypes['productsV5SandboxOnlyUnchangedByProcessId'][0])
    {

        // verify the required parameter 'processUuid' is set
        if ($processUuid === null || (is_array($processUuid) && count($processUuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $processUuid when calling productsV5SandboxOnlyUnchangedByProcessId'
            );
        }


        $resourcePath = '/v5/products/update-tasks/{processUuid}/unchanged';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($processUuid !== null) {
            $resourcePath = str_replace(
                '{' . 'processUuid' . '}',
                ObjectSerializer::toPathValue($processUuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5SandboxOnlyUpdateActiveStatus
     *
     * Update active status
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ActiveStatusListRequestProductsV5SandboxOnly|null $activeStatusListRequestProductsV5SandboxOnly activeStatusListRequestProductsV5SandboxOnly (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyUpdateActiveStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly
     */
    public function productsV5SandboxOnlyUpdateActiveStatus($xRequestTimestamp = null, $activeStatusListRequestProductsV5SandboxOnly = null, string $contentType = self::contentTypes['productsV5SandboxOnlyUpdateActiveStatus'][0])
    {
        list($response) = $this->productsV5SandboxOnlyUpdateActiveStatusWithHttpInfo($xRequestTimestamp, $activeStatusListRequestProductsV5SandboxOnly, $contentType);
        return $response;
    }

    /**
     * Operation productsV5SandboxOnlyUpdateActiveStatusWithHttpInfo
     *
     * Update active status
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ActiveStatusListRequestProductsV5SandboxOnly|null $activeStatusListRequestProductsV5SandboxOnly (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyUpdateActiveStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5SandboxOnlyUpdateActiveStatusWithHttpInfo($xRequestTimestamp = null, $activeStatusListRequestProductsV5SandboxOnly = null, string $contentType = self::contentTypes['productsV5SandboxOnlyUpdateActiveStatus'][0])
    {
        $request = $this->productsV5SandboxOnlyUpdateActiveStatusRequest($xRequestTimestamp, $activeStatusListRequestProductsV5SandboxOnly, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5SandboxOnlyUpdateActiveStatusAsync
     *
     * Update active status
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ActiveStatusListRequestProductsV5SandboxOnly|null $activeStatusListRequestProductsV5SandboxOnly (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyUpdateActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyUpdateActiveStatusAsync($xRequestTimestamp = null, $activeStatusListRequestProductsV5SandboxOnly = null, string $contentType = self::contentTypes['productsV5SandboxOnlyUpdateActiveStatus'][0])
    {
        return $this->productsV5SandboxOnlyUpdateActiveStatusAsyncWithHttpInfo($xRequestTimestamp, $activeStatusListRequestProductsV5SandboxOnly, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5SandboxOnlyUpdateActiveStatusAsyncWithHttpInfo
     *
     * Update active status
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ActiveStatusListRequestProductsV5SandboxOnly|null $activeStatusListRequestProductsV5SandboxOnly (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyUpdateActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyUpdateActiveStatusAsyncWithHttpInfo($xRequestTimestamp = null, $activeStatusListRequestProductsV5SandboxOnly = null, string $contentType = self::contentTypes['productsV5SandboxOnlyUpdateActiveStatus'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly';
        $request = $this->productsV5SandboxOnlyUpdateActiveStatusRequest($xRequestTimestamp, $activeStatusListRequestProductsV5SandboxOnly, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5SandboxOnlyUpdateActiveStatus'
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ActiveStatusListRequestProductsV5SandboxOnly|null $activeStatusListRequestProductsV5SandboxOnly (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyUpdateActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV5SandboxOnlyUpdateActiveStatusRequest($xRequestTimestamp = null, $activeStatusListRequestProductsV5SandboxOnly = null, string $contentType = self::contentTypes['productsV5SandboxOnlyUpdateActiveStatus'][0])
    {




        $resourcePath = '/v5/products/active-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($xRequestTimestamp !== null) {
            $headerParams['X-Request-Timestamp'] = ObjectSerializer::toHeaderValue($xRequestTimestamp);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($activeStatusListRequestProductsV5SandboxOnly)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($activeStatusListRequestProductsV5SandboxOnly));
            } else {
                $httpBody = $activeStatusListRequestProductsV5SandboxOnly;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5SandboxOnlyUpdateProductVariationPrices
     *
     * Update product variation prices
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\SkuPricingProductsV5SandboxOnly[]|null $skuPricingProductsV5SandboxOnly skuPricingProductsV5SandboxOnly (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyUpdateProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly
     */
    public function productsV5SandboxOnlyUpdateProductVariationPrices($xRequestTimestamp = null, $skuPricingProductsV5SandboxOnly = null, string $contentType = self::contentTypes['productsV5SandboxOnlyUpdateProductVariationPrices'][0])
    {
        list($response) = $this->productsV5SandboxOnlyUpdateProductVariationPricesWithHttpInfo($xRequestTimestamp, $skuPricingProductsV5SandboxOnly, $contentType);
        return $response;
    }

    /**
     * Operation productsV5SandboxOnlyUpdateProductVariationPricesWithHttpInfo
     *
     * Update product variation prices
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\SkuPricingProductsV5SandboxOnly[]|null $skuPricingProductsV5SandboxOnly (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyUpdateProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5SandboxOnlyUpdateProductVariationPricesWithHttpInfo($xRequestTimestamp = null, $skuPricingProductsV5SandboxOnly = null, string $contentType = self::contentTypes['productsV5SandboxOnlyUpdateProductVariationPrices'][0])
    {
        $request = $this->productsV5SandboxOnlyUpdateProductVariationPricesRequest($xRequestTimestamp, $skuPricingProductsV5SandboxOnly, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5SandboxOnlyUpdateProductVariationPricesAsync
     *
     * Update product variation prices
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\SkuPricingProductsV5SandboxOnly[]|null $skuPricingProductsV5SandboxOnly (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyUpdateProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyUpdateProductVariationPricesAsync($xRequestTimestamp = null, $skuPricingProductsV5SandboxOnly = null, string $contentType = self::contentTypes['productsV5SandboxOnlyUpdateProductVariationPrices'][0])
    {
        return $this->productsV5SandboxOnlyUpdateProductVariationPricesAsyncWithHttpInfo($xRequestTimestamp, $skuPricingProductsV5SandboxOnly, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5SandboxOnlyUpdateProductVariationPricesAsyncWithHttpInfo
     *
     * Update product variation prices
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\SkuPricingProductsV5SandboxOnly[]|null $skuPricingProductsV5SandboxOnly (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyUpdateProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SandboxOnlyUpdateProductVariationPricesAsyncWithHttpInfo($xRequestTimestamp = null, $skuPricingProductsV5SandboxOnly = null, string $contentType = self::contentTypes['productsV5SandboxOnlyUpdateProductVariationPrices'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV5SandboxOnly';
        $request = $this->productsV5SandboxOnlyUpdateProductVariationPricesRequest($xRequestTimestamp, $skuPricingProductsV5SandboxOnly, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5SandboxOnlyUpdateProductVariationPrices'
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\SkuPricingProductsV5SandboxOnly[]|null $skuPricingProductsV5SandboxOnly (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV5SandboxOnlyUpdateProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV5SandboxOnlyUpdateProductVariationPricesRequest($xRequestTimestamp = null, $skuPricingProductsV5SandboxOnly = null, string $contentType = self::contentTypes['productsV5SandboxOnlyUpdateProductVariationPrices'][0])
    {




        $resourcePath = '/v5/products/prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($xRequestTimestamp !== null) {
            $headerParams['X-Request-Timestamp'] = ObjectSerializer::toHeaderValue($xRequestTimestamp);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($skuPricingProductsV5SandboxOnly)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($skuPricingProductsV5SandboxOnly));
            } else {
                $httpBody = $skuPricingProductsV5SandboxOnly;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
