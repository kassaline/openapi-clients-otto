<?php
/**
 * ProductsV4Api
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client\Otto
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * OTTO Market API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Otto\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\Otto\ApiException;
use OpenAPI\Client\Otto\Configuration;
use OpenAPI\Client\Otto\HeaderSelector;
use OpenAPI\Client\Otto\ObjectSerializer;

/**
 * ProductsV4Api Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client\Otto
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ProductsV4Api
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'productsV4CreateOrUpdateProductVariations' => [
            'application/json',
        ],
        'productsV4FailedByProcessId' => [
            'application/json',
        ],
        'productsV4GetActiveStatus' => [
            'application/json',
        ],
        'productsV4GetBrands' => [
            'application/json',
        ],
        'productsV4GetCategoryGroups' => [
            'application/json',
        ],
        'productsV4GetContentChanges' => [
            'application/json',
        ],
        'productsV4GetContentChanges2' => [
            'application/json',
        ],
        'productsV4GetMarketPlaceStatus' => [
            'application/json',
        ],
        'productsV4GetMarketPlaceStatusList' => [
            'application/json',
        ],
        'productsV4GetPartnerProducts' => [
            'application/json',
        ],
        'productsV4GetProductVariation' => [
            'application/json',
        ],
        'productsV4GetProductVariationPrice' => [
            'application/json',
        ],
        'productsV4GetProductVariationPrices' => [
            'application/json',
        ],
        'productsV4GetVariationActiveStatus' => [
            'application/json',
        ],
        'productsV4ProgressByProcessId' => [
            'application/json',
        ],
        'productsV4SucceededByProcessId' => [
            'application/json',
        ],
        'productsV4UnchangedByProcessId' => [
            'application/json',
        ],
        'productsV4UpdateActiveStatus' => [
            'application/json',
        ],
        'productsV4UpdateProductVariationPrices' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation productsV4CreateOrUpdateProductVariations
     *
     * Create or update product variations
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ProductVariationProductsV4[]|null $productVariationProductsV4 productVariationProductsV4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4CreateOrUpdateProductVariations'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4
     */
    public function productsV4CreateOrUpdateProductVariations($xRequestTimestamp = null, $productVariationProductsV4 = null, string $contentType = self::contentTypes['productsV4CreateOrUpdateProductVariations'][0])
    {
        list($response) = $this->productsV4CreateOrUpdateProductVariationsWithHttpInfo($xRequestTimestamp, $productVariationProductsV4, $contentType);
        return $response;
    }

    /**
     * Operation productsV4CreateOrUpdateProductVariationsWithHttpInfo
     *
     * Create or update product variations
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ProductVariationProductsV4[]|null $productVariationProductsV4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4CreateOrUpdateProductVariations'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4CreateOrUpdateProductVariationsWithHttpInfo($xRequestTimestamp = null, $productVariationProductsV4 = null, string $contentType = self::contentTypes['productsV4CreateOrUpdateProductVariations'][0])
    {
        $request = $this->productsV4CreateOrUpdateProductVariationsRequest($xRequestTimestamp, $productVariationProductsV4, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4CreateOrUpdateProductVariationsAsync
     *
     * Create or update product variations
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ProductVariationProductsV4[]|null $productVariationProductsV4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4CreateOrUpdateProductVariations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4CreateOrUpdateProductVariationsAsync($xRequestTimestamp = null, $productVariationProductsV4 = null, string $contentType = self::contentTypes['productsV4CreateOrUpdateProductVariations'][0])
    {
        return $this->productsV4CreateOrUpdateProductVariationsAsyncWithHttpInfo($xRequestTimestamp, $productVariationProductsV4, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4CreateOrUpdateProductVariationsAsyncWithHttpInfo
     *
     * Create or update product variations
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ProductVariationProductsV4[]|null $productVariationProductsV4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4CreateOrUpdateProductVariations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4CreateOrUpdateProductVariationsAsyncWithHttpInfo($xRequestTimestamp = null, $productVariationProductsV4 = null, string $contentType = self::contentTypes['productsV4CreateOrUpdateProductVariations'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4';
        $request = $this->productsV4CreateOrUpdateProductVariationsRequest($xRequestTimestamp, $productVariationProductsV4, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4CreateOrUpdateProductVariations'
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ProductVariationProductsV4[]|null $productVariationProductsV4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4CreateOrUpdateProductVariations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV4CreateOrUpdateProductVariationsRequest($xRequestTimestamp = null, $productVariationProductsV4 = null, string $contentType = self::contentTypes['productsV4CreateOrUpdateProductVariations'][0])
    {




        $resourcePath = '/v4/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($xRequestTimestamp !== null) {
            $headerParams['X-Request-Timestamp'] = ObjectSerializer::toHeaderValue($xRequestTimestamp);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($productVariationProductsV4)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($productVariationProductsV4));
            } else {
                $httpBody = $productVariationProductsV4;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4FailedByProcessId
     *
     * List failed products of a product data delivery
     *
     * @param  string $processUuid search for the failed products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4FailedByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4
     */
    public function productsV4FailedByProcessId($processUuid, string $contentType = self::contentTypes['productsV4FailedByProcessId'][0])
    {
        list($response) = $this->productsV4FailedByProcessIdWithHttpInfo($processUuid, $contentType);
        return $response;
    }

    /**
     * Operation productsV4FailedByProcessIdWithHttpInfo
     *
     * List failed products of a product data delivery
     *
     * @param  string $processUuid search for the failed products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4FailedByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4FailedByProcessIdWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV4FailedByProcessId'][0])
    {
        $request = $this->productsV4FailedByProcessIdRequest($processUuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4FailedByProcessIdAsync
     *
     * List failed products of a product data delivery
     *
     * @param  string $processUuid search for the failed products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4FailedByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4FailedByProcessIdAsync($processUuid, string $contentType = self::contentTypes['productsV4FailedByProcessId'][0])
    {
        return $this->productsV4FailedByProcessIdAsyncWithHttpInfo($processUuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4FailedByProcessIdAsyncWithHttpInfo
     *
     * List failed products of a product data delivery
     *
     * @param  string $processUuid search for the failed products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4FailedByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4FailedByProcessIdAsyncWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV4FailedByProcessId'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4';
        $request = $this->productsV4FailedByProcessIdRequest($processUuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4FailedByProcessId'
     *
     * @param  string $processUuid search for the failed products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4FailedByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV4FailedByProcessIdRequest($processUuid, string $contentType = self::contentTypes['productsV4FailedByProcessId'][0])
    {

        // verify the required parameter 'processUuid' is set
        if ($processUuid === null || (is_array($processUuid) && count($processUuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $processUuid when calling productsV4FailedByProcessId'
            );
        }


        $resourcePath = '/v4/products/update-tasks/{processUuid}/failed';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($processUuid !== null) {
            $resourcePath = str_replace(
                '{' . 'processUuid' . '}',
                ObjectSerializer::toPathValue($processUuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetActiveStatus
     *
     * Read active status
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brand ID value (optional)
     * @param  int|null $page page (optional)
     * @param  int|null $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetActiveStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV4
     */
    public function productsV4GetActiveStatus($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetActiveStatus'][0])
    {
        list($response) = $this->productsV4GetActiveStatusWithHttpInfo($sku, $productReference, $category, $brandId, $page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation productsV4GetActiveStatusWithHttpInfo
     *
     * Read active status
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brand ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetActiveStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetActiveStatusWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetActiveStatus'][0])
    {
        $request = $this->productsV4GetActiveStatusRequest($sku, $productReference, $category, $brandId, $page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetActiveStatusAsync
     *
     * Read active status
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brand ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetActiveStatusAsync($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetActiveStatus'][0])
    {
        return $this->productsV4GetActiveStatusAsyncWithHttpInfo($sku, $productReference, $category, $brandId, $page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetActiveStatusAsyncWithHttpInfo
     *
     * Read active status
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brand ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetActiveStatusAsyncWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetActiveStatus'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ActiveStatusListResponseProductsV4';
        $request = $this->productsV4GetActiveStatusRequest($sku, $productReference, $category, $brandId, $page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetActiveStatus'
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brand ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV4GetActiveStatusRequest($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetActiveStatus'][0])
    {








        $resourcePath = '/v4/products/active-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $productReference,
            'productReference', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brandId,
            'brandId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetBrands
     *
     * List of allowed brands
     *
     * @param  string|null $ifMatch The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string|null $ifNoneMatch The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string|null $ifModifiedSince The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#39;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#39;s data is avoided if that data has not changed. (optional)
     * @param  string|null $ifUnmodifiedSince The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#39;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int|null $page page (optional)
     * @param  int|null $limit limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetBrands'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\BrandListResponseProductsV4
     */
    public function productsV4GetBrands($ifMatch = null, $ifNoneMatch = null, $ifModifiedSince = null, $ifUnmodifiedSince = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetBrands'][0])
    {
        list($response) = $this->productsV4GetBrandsWithHttpInfo($ifMatch, $ifNoneMatch, $ifModifiedSince, $ifUnmodifiedSince, $page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation productsV4GetBrandsWithHttpInfo
     *
     * List of allowed brands
     *
     * @param  string|null $ifMatch The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string|null $ifNoneMatch The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string|null $ifModifiedSince The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#39;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#39;s data is avoided if that data has not changed. (optional)
     * @param  string|null $ifUnmodifiedSince The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#39;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetBrands'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\BrandListResponseProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetBrandsWithHttpInfo($ifMatch = null, $ifNoneMatch = null, $ifModifiedSince = null, $ifUnmodifiedSince = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetBrands'][0])
    {
        $request = $this->productsV4GetBrandsRequest($ifMatch, $ifNoneMatch, $ifModifiedSince, $ifUnmodifiedSince, $page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\BrandListResponseProductsV4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\BrandListResponseProductsV4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\BrandListResponseProductsV4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\BrandListResponseProductsV4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\BrandListResponseProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetBrandsAsync
     *
     * List of allowed brands
     *
     * @param  string|null $ifMatch The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string|null $ifNoneMatch The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string|null $ifModifiedSince The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#39;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#39;s data is avoided if that data has not changed. (optional)
     * @param  string|null $ifUnmodifiedSince The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#39;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetBrands'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetBrandsAsync($ifMatch = null, $ifNoneMatch = null, $ifModifiedSince = null, $ifUnmodifiedSince = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetBrands'][0])
    {
        return $this->productsV4GetBrandsAsyncWithHttpInfo($ifMatch, $ifNoneMatch, $ifModifiedSince, $ifUnmodifiedSince, $page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetBrandsAsyncWithHttpInfo
     *
     * List of allowed brands
     *
     * @param  string|null $ifMatch The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string|null $ifNoneMatch The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string|null $ifModifiedSince The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#39;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#39;s data is avoided if that data has not changed. (optional)
     * @param  string|null $ifUnmodifiedSince The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#39;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetBrands'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetBrandsAsyncWithHttpInfo($ifMatch = null, $ifNoneMatch = null, $ifModifiedSince = null, $ifUnmodifiedSince = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetBrands'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\BrandListResponseProductsV4';
        $request = $this->productsV4GetBrandsRequest($ifMatch, $ifNoneMatch, $ifModifiedSince, $ifUnmodifiedSince, $page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetBrands'
     *
     * @param  string|null $ifMatch The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string|null $ifNoneMatch The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string|null $ifModifiedSince The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#39;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#39;s data is avoided if that data has not changed. (optional)
     * @param  string|null $ifUnmodifiedSince The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#39;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetBrands'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV4GetBrandsRequest($ifMatch = null, $ifNoneMatch = null, $ifModifiedSince = null, $ifUnmodifiedSince = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetBrands'][0])
    {








        $resourcePath = '/v4/products/brands';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($ifMatch !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($ifMatch);
        }
        // header params
        if ($ifNoneMatch !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($ifNoneMatch);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }
        // header params
        if ($ifUnmodifiedSince !== null) {
            $headerParams['If-Unmodified-Since'] = ObjectSerializer::toHeaderValue($ifUnmodifiedSince);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetCategoryGroups
     *
     * Read product categories
     *
     * @param  int|null $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int|null $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string|null $category read a single category (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetCategoryGroups'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\CategoryGroupsProductsV4
     */
    public function productsV4GetCategoryGroups($page = null, $limit = null, $category = null, string $contentType = self::contentTypes['productsV4GetCategoryGroups'][0])
    {
        list($response) = $this->productsV4GetCategoryGroupsWithHttpInfo($page, $limit, $category, $contentType);
        return $response;
    }

    /**
     * Operation productsV4GetCategoryGroupsWithHttpInfo
     *
     * Read product categories
     *
     * @param  int|null $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int|null $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string|null $category read a single category (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetCategoryGroups'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\CategoryGroupsProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetCategoryGroupsWithHttpInfo($page = null, $limit = null, $category = null, string $contentType = self::contentTypes['productsV4GetCategoryGroups'][0])
    {
        $request = $this->productsV4GetCategoryGroupsRequest($page, $limit, $category, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\CategoryGroupsProductsV4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\CategoryGroupsProductsV4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\CategoryGroupsProductsV4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\CategoryGroupsProductsV4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\CategoryGroupsProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetCategoryGroupsAsync
     *
     * Read product categories
     *
     * @param  int|null $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int|null $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string|null $category read a single category (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetCategoryGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetCategoryGroupsAsync($page = null, $limit = null, $category = null, string $contentType = self::contentTypes['productsV4GetCategoryGroups'][0])
    {
        return $this->productsV4GetCategoryGroupsAsyncWithHttpInfo($page, $limit, $category, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetCategoryGroupsAsyncWithHttpInfo
     *
     * Read product categories
     *
     * @param  int|null $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int|null $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string|null $category read a single category (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetCategoryGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetCategoryGroupsAsyncWithHttpInfo($page = null, $limit = null, $category = null, string $contentType = self::contentTypes['productsV4GetCategoryGroups'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\CategoryGroupsProductsV4';
        $request = $this->productsV4GetCategoryGroupsRequest($page, $limit, $category, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetCategoryGroups'
     *
     * @param  int|null $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int|null $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string|null $category read a single category (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetCategoryGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV4GetCategoryGroupsRequest($page = null, $limit = null, $category = null, string $contentType = self::contentTypes['productsV4GetCategoryGroups'][0])
    {





        $resourcePath = '/v4/products/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetContentChanges
     *
     * Read content changes for a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime|null $fromDate search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page page (optional)
     * @param  int|null $limit proposed limit for the number of entries per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetContentChanges'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV4
     */
    public function productsV4GetContentChanges($sku, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetContentChanges'][0])
    {
        list($response) = $this->productsV4GetContentChangesWithHttpInfo($sku, $fromDate, $page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation productsV4GetContentChangesWithHttpInfo
     *
     * Read content changes for a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime|null $fromDate search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of entries per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetContentChanges'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetContentChangesWithHttpInfo($sku, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetContentChanges'][0])
    {
        $request = $this->productsV4GetContentChangesRequest($sku, $fromDate, $page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetContentChangesAsync
     *
     * Read content changes for a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime|null $fromDate search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of entries per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetContentChanges'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetContentChangesAsync($sku, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetContentChanges'][0])
    {
        return $this->productsV4GetContentChangesAsyncWithHttpInfo($sku, $fromDate, $page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetContentChangesAsyncWithHttpInfo
     *
     * Read content changes for a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime|null $fromDate search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of entries per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetContentChanges'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetContentChangesAsyncWithHttpInfo($sku, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetContentChanges'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV4';
        $request = $this->productsV4GetContentChangesRequest($sku, $fromDate, $page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetContentChanges'
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime|null $fromDate search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of entries per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetContentChanges'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV4GetContentChangesRequest($sku, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetContentChanges'][0])
    {

        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV4GetContentChanges'
            );
        }





        $resourcePath = '/v4/products/{sku}/content-changes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fromDate,
            'fromDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetContentChanges2
     *
     * Read content changes within time period
     *
     * @param  string[]|null $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime|null $fromDate search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page page (optional)
     * @param  int|null $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetContentChanges2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV4
     */
    public function productsV4GetContentChanges2($sku = null, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetContentChanges2'][0])
    {
        list($response) = $this->productsV4GetContentChanges2WithHttpInfo($sku, $fromDate, $page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation productsV4GetContentChanges2WithHttpInfo
     *
     * Read content changes within time period
     *
     * @param  string[]|null $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime|null $fromDate search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetContentChanges2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetContentChanges2WithHttpInfo($sku = null, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetContentChanges2'][0])
    {
        $request = $this->productsV4GetContentChanges2Request($sku, $fromDate, $page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetContentChanges2Async
     *
     * Read content changes within time period
     *
     * @param  string[]|null $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime|null $fromDate search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetContentChanges2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetContentChanges2Async($sku = null, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetContentChanges2'][0])
    {
        return $this->productsV4GetContentChanges2AsyncWithHttpInfo($sku, $fromDate, $page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetContentChanges2AsyncWithHttpInfo
     *
     * Read content changes within time period
     *
     * @param  string[]|null $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime|null $fromDate search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetContentChanges2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetContentChanges2AsyncWithHttpInfo($sku = null, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetContentChanges2'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ContentChangesApiResultProductsV4';
        $request = $this->productsV4GetContentChanges2Request($sku, $fromDate, $page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetContentChanges2'
     *
     * @param  string[]|null $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime|null $fromDate search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetContentChanges2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV4GetContentChanges2Request($sku = null, $fromDate = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetContentChanges2'][0])
    {






        $resourcePath = '/v4/products/content-changes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fromDate,
            'fromDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetMarketPlaceStatus
     *
     * Read marketplace status for a single product variation
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetMarketPlaceStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV4
     */
    public function productsV4GetMarketPlaceStatus($sku, string $contentType = self::contentTypes['productsV4GetMarketPlaceStatus'][0])
    {
        list($response) = $this->productsV4GetMarketPlaceStatusWithHttpInfo($sku, $contentType);
        return $response;
    }

    /**
     * Operation productsV4GetMarketPlaceStatusWithHttpInfo
     *
     * Read marketplace status for a single product variation
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetMarketPlaceStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetMarketPlaceStatusWithHttpInfo($sku, string $contentType = self::contentTypes['productsV4GetMarketPlaceStatus'][0])
    {
        $request = $this->productsV4GetMarketPlaceStatusRequest($sku, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetMarketPlaceStatusAsync
     *
     * Read marketplace status for a single product variation
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetMarketPlaceStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetMarketPlaceStatusAsync($sku, string $contentType = self::contentTypes['productsV4GetMarketPlaceStatus'][0])
    {
        return $this->productsV4GetMarketPlaceStatusAsyncWithHttpInfo($sku, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetMarketPlaceStatusAsyncWithHttpInfo
     *
     * Read marketplace status for a single product variation
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetMarketPlaceStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetMarketPlaceStatusAsyncWithHttpInfo($sku, string $contentType = self::contentTypes['productsV4GetMarketPlaceStatus'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\MarketPlaceStatusProductsV4';
        $request = $this->productsV4GetMarketPlaceStatusRequest($sku, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetMarketPlaceStatus'
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetMarketPlaceStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV4GetMarketPlaceStatusRequest($sku, string $contentType = self::contentTypes['productsV4GetMarketPlaceStatus'][0])
    {

        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV4GetMarketPlaceStatus'
            );
        }


        $resourcePath = '/v4/products/{sku}/marketplace-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetMarketPlaceStatusList
     *
     * Read marketplace status of product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string|null $category search marketplace status by the category value of the related product variations (optional)
     * @param  string|null $brandId search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime|null $fromDate search marketplace status for a time range starting with the given date (in ISO8601, like &#39;2021-10-09T07:52:19.820Z&#39; or &#39;2021-10-09T07:52:19.820+01:00&#39;) (optional)
     * @param  int|null $page page to load (optional)
     * @param  int|null $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[]|null $marketPlaceStatus only include items that match any of the provided status (optional)
     * @param  string|null $sortOrder Define the sort order of the resulting entries. Available values are &#39;desc&#39; for &#39;newest lastModified first&#39; and &#39;asc&#39; for &#39;oldest lastModified first&#39; - default is &#39;desc&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetMarketPlaceStatusList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV4
     */
    public function productsV4GetMarketPlaceStatusList($sku = null, $productReference = null, $category = null, $brandId = null, $fromDate = null, $page = null, $limit = null, $marketPlaceStatus = null, $sortOrder = null, string $contentType = self::contentTypes['productsV4GetMarketPlaceStatusList'][0])
    {
        list($response) = $this->productsV4GetMarketPlaceStatusListWithHttpInfo($sku, $productReference, $category, $brandId, $fromDate, $page, $limit, $marketPlaceStatus, $sortOrder, $contentType);
        return $response;
    }

    /**
     * Operation productsV4GetMarketPlaceStatusListWithHttpInfo
     *
     * Read marketplace status of product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string|null $category search marketplace status by the category value of the related product variations (optional)
     * @param  string|null $brandId search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime|null $fromDate search marketplace status for a time range starting with the given date (in ISO8601, like &#39;2021-10-09T07:52:19.820Z&#39; or &#39;2021-10-09T07:52:19.820+01:00&#39;) (optional)
     * @param  int|null $page page to load (optional)
     * @param  int|null $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[]|null $marketPlaceStatus only include items that match any of the provided status (optional)
     * @param  string|null $sortOrder Define the sort order of the resulting entries. Available values are &#39;desc&#39; for &#39;newest lastModified first&#39; and &#39;asc&#39; for &#39;oldest lastModified first&#39; - default is &#39;desc&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetMarketPlaceStatusList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetMarketPlaceStatusListWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $fromDate = null, $page = null, $limit = null, $marketPlaceStatus = null, $sortOrder = null, string $contentType = self::contentTypes['productsV4GetMarketPlaceStatusList'][0])
    {
        $request = $this->productsV4GetMarketPlaceStatusListRequest($sku, $productReference, $category, $brandId, $fromDate, $page, $limit, $marketPlaceStatus, $sortOrder, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetMarketPlaceStatusListAsync
     *
     * Read marketplace status of product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string|null $category search marketplace status by the category value of the related product variations (optional)
     * @param  string|null $brandId search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime|null $fromDate search marketplace status for a time range starting with the given date (in ISO8601, like &#39;2021-10-09T07:52:19.820Z&#39; or &#39;2021-10-09T07:52:19.820+01:00&#39;) (optional)
     * @param  int|null $page page to load (optional)
     * @param  int|null $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[]|null $marketPlaceStatus only include items that match any of the provided status (optional)
     * @param  string|null $sortOrder Define the sort order of the resulting entries. Available values are &#39;desc&#39; for &#39;newest lastModified first&#39; and &#39;asc&#39; for &#39;oldest lastModified first&#39; - default is &#39;desc&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetMarketPlaceStatusList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetMarketPlaceStatusListAsync($sku = null, $productReference = null, $category = null, $brandId = null, $fromDate = null, $page = null, $limit = null, $marketPlaceStatus = null, $sortOrder = null, string $contentType = self::contentTypes['productsV4GetMarketPlaceStatusList'][0])
    {
        return $this->productsV4GetMarketPlaceStatusListAsyncWithHttpInfo($sku, $productReference, $category, $brandId, $fromDate, $page, $limit, $marketPlaceStatus, $sortOrder, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetMarketPlaceStatusListAsyncWithHttpInfo
     *
     * Read marketplace status of product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string|null $category search marketplace status by the category value of the related product variations (optional)
     * @param  string|null $brandId search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime|null $fromDate search marketplace status for a time range starting with the given date (in ISO8601, like &#39;2021-10-09T07:52:19.820Z&#39; or &#39;2021-10-09T07:52:19.820+01:00&#39;) (optional)
     * @param  int|null $page page to load (optional)
     * @param  int|null $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[]|null $marketPlaceStatus only include items that match any of the provided status (optional)
     * @param  string|null $sortOrder Define the sort order of the resulting entries. Available values are &#39;desc&#39; for &#39;newest lastModified first&#39; and &#39;asc&#39; for &#39;oldest lastModified first&#39; - default is &#39;desc&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetMarketPlaceStatusList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetMarketPlaceStatusListAsyncWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $fromDate = null, $page = null, $limit = null, $marketPlaceStatus = null, $sortOrder = null, string $contentType = self::contentTypes['productsV4GetMarketPlaceStatusList'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\MarketPlaceStatusApiResultProductsV4';
        $request = $this->productsV4GetMarketPlaceStatusListRequest($sku, $productReference, $category, $brandId, $fromDate, $page, $limit, $marketPlaceStatus, $sortOrder, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetMarketPlaceStatusList'
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string|null $category search marketplace status by the category value of the related product variations (optional)
     * @param  string|null $brandId search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime|null $fromDate search marketplace status for a time range starting with the given date (in ISO8601, like &#39;2021-10-09T07:52:19.820Z&#39; or &#39;2021-10-09T07:52:19.820+01:00&#39;) (optional)
     * @param  int|null $page page to load (optional)
     * @param  int|null $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[]|null $marketPlaceStatus only include items that match any of the provided status (optional)
     * @param  string|null $sortOrder Define the sort order of the resulting entries. Available values are &#39;desc&#39; for &#39;newest lastModified first&#39; and &#39;asc&#39; for &#39;oldest lastModified first&#39; - default is &#39;desc&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetMarketPlaceStatusList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV4GetMarketPlaceStatusListRequest($sku = null, $productReference = null, $category = null, $brandId = null, $fromDate = null, $page = null, $limit = null, $marketPlaceStatus = null, $sortOrder = null, string $contentType = self::contentTypes['productsV4GetMarketPlaceStatusList'][0])
    {











        $resourcePath = '/v4/products/marketplace-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $productReference,
            'productReference', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brandId,
            'brandId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fromDate,
            'fromDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $marketPlaceStatus,
            'marketPlaceStatus', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sortOrder,
            'sort-order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetPartnerProducts
     *
     * Read product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brandId value (optional)
     * @param  int|null $page page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetPartnerProducts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV4
     */
    public function productsV4GetPartnerProducts($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetPartnerProducts'][0])
    {
        list($response) = $this->productsV4GetPartnerProductsWithHttpInfo($sku, $productReference, $category, $brandId, $page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation productsV4GetPartnerProductsWithHttpInfo
     *
     * Read product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brandId value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetPartnerProducts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetPartnerProductsWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetPartnerProducts'][0])
    {
        $request = $this->productsV4GetPartnerProductsRequest($sku, $productReference, $category, $brandId, $page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetPartnerProductsAsync
     *
     * Read product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brandId value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetPartnerProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetPartnerProductsAsync($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetPartnerProducts'][0])
    {
        return $this->productsV4GetPartnerProductsAsyncWithHttpInfo($sku, $productReference, $category, $brandId, $page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetPartnerProductsAsyncWithHttpInfo
     *
     * Read product variations
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brandId value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetPartnerProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetPartnerProductsAsyncWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetPartnerProducts'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductVariationApiResultProductsV4';
        $request = $this->productsV4GetPartnerProductsRequest($sku, $productReference, $category, $brandId, $page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetPartnerProducts'
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their brandId value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetPartnerProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV4GetPartnerProductsRequest($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetPartnerProducts'][0])
    {








        $resourcePath = '/v4/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $productReference,
            'productReference', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brandId,
            'brandId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetProductVariation
     *
     * Read a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetProductVariation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductVariationProductsV4
     */
    public function productsV4GetProductVariation($sku, string $contentType = self::contentTypes['productsV4GetProductVariation'][0])
    {
        list($response) = $this->productsV4GetProductVariationWithHttpInfo($sku, $contentType);
        return $response;
    }

    /**
     * Operation productsV4GetProductVariationWithHttpInfo
     *
     * Read a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetProductVariation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductVariationProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetProductVariationWithHttpInfo($sku, string $contentType = self::contentTypes['productsV4GetProductVariation'][0])
    {
        $request = $this->productsV4GetProductVariationRequest($sku, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ProductVariationProductsV4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductVariationProductsV4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductVariationProductsV4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductVariationProductsV4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductVariationProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetProductVariationAsync
     *
     * Read a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetProductVariation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetProductVariationAsync($sku, string $contentType = self::contentTypes['productsV4GetProductVariation'][0])
    {
        return $this->productsV4GetProductVariationAsyncWithHttpInfo($sku, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetProductVariationAsyncWithHttpInfo
     *
     * Read a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetProductVariation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetProductVariationAsyncWithHttpInfo($sku, string $contentType = self::contentTypes['productsV4GetProductVariation'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductVariationProductsV4';
        $request = $this->productsV4GetProductVariationRequest($sku, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetProductVariation'
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetProductVariation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV4GetProductVariationRequest($sku, string $contentType = self::contentTypes['productsV4GetProductVariation'][0])
    {

        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV4GetProductVariation'
            );
        }


        $resourcePath = '/v4/products/{sku}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetProductVariationPrice
     *
     * Read a single product variation price
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetProductVariationPrice'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\SkuPricingProductsV4
     */
    public function productsV4GetProductVariationPrice($sku, string $contentType = self::contentTypes['productsV4GetProductVariationPrice'][0])
    {
        list($response) = $this->productsV4GetProductVariationPriceWithHttpInfo($sku, $contentType);
        return $response;
    }

    /**
     * Operation productsV4GetProductVariationPriceWithHttpInfo
     *
     * Read a single product variation price
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetProductVariationPrice'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\SkuPricingProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetProductVariationPriceWithHttpInfo($sku, string $contentType = self::contentTypes['productsV4GetProductVariationPrice'][0])
    {
        $request = $this->productsV4GetProductVariationPriceRequest($sku, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\SkuPricingProductsV4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\SkuPricingProductsV4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\SkuPricingProductsV4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\SkuPricingProductsV4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\SkuPricingProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetProductVariationPriceAsync
     *
     * Read a single product variation price
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetProductVariationPrice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetProductVariationPriceAsync($sku, string $contentType = self::contentTypes['productsV4GetProductVariationPrice'][0])
    {
        return $this->productsV4GetProductVariationPriceAsyncWithHttpInfo($sku, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetProductVariationPriceAsyncWithHttpInfo
     *
     * Read a single product variation price
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetProductVariationPrice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetProductVariationPriceAsyncWithHttpInfo($sku, string $contentType = self::contentTypes['productsV4GetProductVariationPrice'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\SkuPricingProductsV4';
        $request = $this->productsV4GetProductVariationPriceRequest($sku, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetProductVariationPrice'
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetProductVariationPrice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV4GetProductVariationPriceRequest($sku, string $contentType = self::contentTypes['productsV4GetProductVariationPrice'][0])
    {

        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV4GetProductVariationPrice'
            );
        }


        $resourcePath = '/v4/products/{sku}/prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetProductVariationPrices
     *
     * Read product variations prices
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their ID value (optional)
     * @param  int|null $page page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\PriceApiResultProductsV4
     */
    public function productsV4GetProductVariationPrices($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetProductVariationPrices'][0])
    {
        list($response) = $this->productsV4GetProductVariationPricesWithHttpInfo($sku, $productReference, $category, $brandId, $page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation productsV4GetProductVariationPricesWithHttpInfo
     *
     * Read product variations prices
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\PriceApiResultProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetProductVariationPricesWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetProductVariationPrices'][0])
    {
        $request = $this->productsV4GetProductVariationPricesRequest($sku, $productReference, $category, $brandId, $page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\PriceApiResultProductsV4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\PriceApiResultProductsV4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\PriceApiResultProductsV4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\PriceApiResultProductsV4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\PriceApiResultProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetProductVariationPricesAsync
     *
     * Read product variations prices
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetProductVariationPricesAsync($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetProductVariationPrices'][0])
    {
        return $this->productsV4GetProductVariationPricesAsyncWithHttpInfo($sku, $productReference, $category, $brandId, $page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetProductVariationPricesAsyncWithHttpInfo
     *
     * Read product variations prices
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetProductVariationPricesAsyncWithHttpInfo($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetProductVariationPrices'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\PriceApiResultProductsV4';
        $request = $this->productsV4GetProductVariationPricesRequest($sku, $productReference, $category, $brandId, $page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetProductVariationPrices'
     *
     * @param  string|null $sku search for product variations by their sku value. Use this if your sku values contain slash (&#39;/&#39;) or dot (&#39;.&#39;) characters. (optional)
     * @param  string|null $productReference search for product variations by their productReference value (optional)
     * @param  string|null $category search for product variations by their category value (optional)
     * @param  string|null $brandId search for product variations by their ID value (optional)
     * @param  int|null $page (optional)
     * @param  int|null $limit proposed limit for the number of products per response page (at most 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV4GetProductVariationPricesRequest($sku = null, $productReference = null, $category = null, $brandId = null, $page = null, $limit = null, string $contentType = self::contentTypes['productsV4GetProductVariationPrices'][0])
    {








        $resourcePath = '/v4/products/prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $productReference,
            'productReference', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brandId,
            'brandId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetVariationActiveStatus
     *
     * Read the active status of a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetVariationActiveStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ActiveStatusProductsV4
     */
    public function productsV4GetVariationActiveStatus($sku, string $contentType = self::contentTypes['productsV4GetVariationActiveStatus'][0])
    {
        list($response) = $this->productsV4GetVariationActiveStatusWithHttpInfo($sku, $contentType);
        return $response;
    }

    /**
     * Operation productsV4GetVariationActiveStatusWithHttpInfo
     *
     * Read the active status of a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetVariationActiveStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ActiveStatusProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetVariationActiveStatusWithHttpInfo($sku, string $contentType = self::contentTypes['productsV4GetVariationActiveStatus'][0])
    {
        $request = $this->productsV4GetVariationActiveStatusRequest($sku, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ActiveStatusProductsV4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ActiveStatusProductsV4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ActiveStatusProductsV4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ActiveStatusProductsV4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ActiveStatusProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetVariationActiveStatusAsync
     *
     * Read the active status of a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetVariationActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetVariationActiveStatusAsync($sku, string $contentType = self::contentTypes['productsV4GetVariationActiveStatus'][0])
    {
        return $this->productsV4GetVariationActiveStatusAsyncWithHttpInfo($sku, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetVariationActiveStatusAsyncWithHttpInfo
     *
     * Read the active status of a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetVariationActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetVariationActiveStatusAsyncWithHttpInfo($sku, string $contentType = self::contentTypes['productsV4GetVariationActiveStatus'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ActiveStatusProductsV4';
        $request = $this->productsV4GetVariationActiveStatusRequest($sku, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetVariationActiveStatus'
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4GetVariationActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV4GetVariationActiveStatusRequest($sku, string $contentType = self::contentTypes['productsV4GetVariationActiveStatus'][0])
    {

        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV4GetVariationActiveStatus'
            );
        }


        $resourcePath = '/v4/products/{sku}/active-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4ProgressByProcessId
     *
     * Request the results of a product data delivery
     *
     * @param  string $processUuid search for a product data delivery result by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4ProgressByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4
     */
    public function productsV4ProgressByProcessId($processUuid, string $contentType = self::contentTypes['productsV4ProgressByProcessId'][0])
    {
        list($response) = $this->productsV4ProgressByProcessIdWithHttpInfo($processUuid, $contentType);
        return $response;
    }

    /**
     * Operation productsV4ProgressByProcessIdWithHttpInfo
     *
     * Request the results of a product data delivery
     *
     * @param  string $processUuid search for a product data delivery result by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4ProgressByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4ProgressByProcessIdWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV4ProgressByProcessId'][0])
    {
        $request = $this->productsV4ProgressByProcessIdRequest($processUuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4ProgressByProcessIdAsync
     *
     * Request the results of a product data delivery
     *
     * @param  string $processUuid search for a product data delivery result by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4ProgressByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4ProgressByProcessIdAsync($processUuid, string $contentType = self::contentTypes['productsV4ProgressByProcessId'][0])
    {
        return $this->productsV4ProgressByProcessIdAsyncWithHttpInfo($processUuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4ProgressByProcessIdAsyncWithHttpInfo
     *
     * Request the results of a product data delivery
     *
     * @param  string $processUuid search for a product data delivery result by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4ProgressByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4ProgressByProcessIdAsyncWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV4ProgressByProcessId'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4';
        $request = $this->productsV4ProgressByProcessIdRequest($processUuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4ProgressByProcessId'
     *
     * @param  string $processUuid search for a product data delivery result by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4ProgressByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV4ProgressByProcessIdRequest($processUuid, string $contentType = self::contentTypes['productsV4ProgressByProcessId'][0])
    {

        // verify the required parameter 'processUuid' is set
        if ($processUuid === null || (is_array($processUuid) && count($processUuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $processUuid when calling productsV4ProgressByProcessId'
            );
        }


        $resourcePath = '/v4/products/update-tasks/{processUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($processUuid !== null) {
            $resourcePath = str_replace(
                '{' . 'processUuid' . '}',
                ObjectSerializer::toPathValue($processUuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4SucceededByProcessId
     *
     * List succeeded products of a product data delivery
     *
     * @param  string $processUuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4SucceededByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4
     */
    public function productsV4SucceededByProcessId($processUuid, string $contentType = self::contentTypes['productsV4SucceededByProcessId'][0])
    {
        list($response) = $this->productsV4SucceededByProcessIdWithHttpInfo($processUuid, $contentType);
        return $response;
    }

    /**
     * Operation productsV4SucceededByProcessIdWithHttpInfo
     *
     * List succeeded products of a product data delivery
     *
     * @param  string $processUuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4SucceededByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4SucceededByProcessIdWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV4SucceededByProcessId'][0])
    {
        $request = $this->productsV4SucceededByProcessIdRequest($processUuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4SucceededByProcessIdAsync
     *
     * List succeeded products of a product data delivery
     *
     * @param  string $processUuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4SucceededByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4SucceededByProcessIdAsync($processUuid, string $contentType = self::contentTypes['productsV4SucceededByProcessId'][0])
    {
        return $this->productsV4SucceededByProcessIdAsyncWithHttpInfo($processUuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4SucceededByProcessIdAsyncWithHttpInfo
     *
     * List succeeded products of a product data delivery
     *
     * @param  string $processUuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4SucceededByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4SucceededByProcessIdAsyncWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV4SucceededByProcessId'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4';
        $request = $this->productsV4SucceededByProcessIdRequest($processUuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4SucceededByProcessId'
     *
     * @param  string $processUuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4SucceededByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV4SucceededByProcessIdRequest($processUuid, string $contentType = self::contentTypes['productsV4SucceededByProcessId'][0])
    {

        // verify the required parameter 'processUuid' is set
        if ($processUuid === null || (is_array($processUuid) && count($processUuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $processUuid when calling productsV4SucceededByProcessId'
            );
        }


        $resourcePath = '/v4/products/update-tasks/{processUuid}/succeeded';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($processUuid !== null) {
            $resourcePath = str_replace(
                '{' . 'processUuid' . '}',
                ObjectSerializer::toPathValue($processUuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4UnchangedByProcessId
     *
     * List unchanged products of a product data delivery
     *
     * @param  string $processUuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4UnchangedByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4
     */
    public function productsV4UnchangedByProcessId($processUuid, string $contentType = self::contentTypes['productsV4UnchangedByProcessId'][0])
    {
        list($response) = $this->productsV4UnchangedByProcessIdWithHttpInfo($processUuid, $contentType);
        return $response;
    }

    /**
     * Operation productsV4UnchangedByProcessIdWithHttpInfo
     *
     * List unchanged products of a product data delivery
     *
     * @param  string $processUuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4UnchangedByProcessId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4UnchangedByProcessIdWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV4UnchangedByProcessId'][0])
    {
        $request = $this->productsV4UnchangedByProcessIdRequest($processUuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4UnchangedByProcessIdAsync
     *
     * List unchanged products of a product data delivery
     *
     * @param  string $processUuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4UnchangedByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4UnchangedByProcessIdAsync($processUuid, string $contentType = self::contentTypes['productsV4UnchangedByProcessId'][0])
    {
        return $this->productsV4UnchangedByProcessIdAsyncWithHttpInfo($processUuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4UnchangedByProcessIdAsyncWithHttpInfo
     *
     * List unchanged products of a product data delivery
     *
     * @param  string $processUuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4UnchangedByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4UnchangedByProcessIdAsyncWithHttpInfo($processUuid, string $contentType = self::contentTypes['productsV4UnchangedByProcessId'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessResultProductsV4';
        $request = $this->productsV4UnchangedByProcessIdRequest($processUuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4UnchangedByProcessId'
     *
     * @param  string $processUuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4UnchangedByProcessId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV4UnchangedByProcessIdRequest($processUuid, string $contentType = self::contentTypes['productsV4UnchangedByProcessId'][0])
    {

        // verify the required parameter 'processUuid' is set
        if ($processUuid === null || (is_array($processUuid) && count($processUuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $processUuid when calling productsV4UnchangedByProcessId'
            );
        }


        $resourcePath = '/v4/products/update-tasks/{processUuid}/unchanged';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($processUuid !== null) {
            $resourcePath = str_replace(
                '{' . 'processUuid' . '}',
                ObjectSerializer::toPathValue($processUuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4UpdateActiveStatus
     *
     * Update active status
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ActiveStatusListRequestProductsV4|null $activeStatusListRequestProductsV4 activeStatusListRequestProductsV4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4UpdateActiveStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4
     */
    public function productsV4UpdateActiveStatus($xRequestTimestamp = null, $activeStatusListRequestProductsV4 = null, string $contentType = self::contentTypes['productsV4UpdateActiveStatus'][0])
    {
        list($response) = $this->productsV4UpdateActiveStatusWithHttpInfo($xRequestTimestamp, $activeStatusListRequestProductsV4, $contentType);
        return $response;
    }

    /**
     * Operation productsV4UpdateActiveStatusWithHttpInfo
     *
     * Update active status
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ActiveStatusListRequestProductsV4|null $activeStatusListRequestProductsV4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4UpdateActiveStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4UpdateActiveStatusWithHttpInfo($xRequestTimestamp = null, $activeStatusListRequestProductsV4 = null, string $contentType = self::contentTypes['productsV4UpdateActiveStatus'][0])
    {
        $request = $this->productsV4UpdateActiveStatusRequest($xRequestTimestamp, $activeStatusListRequestProductsV4, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4UpdateActiveStatusAsync
     *
     * Update active status
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ActiveStatusListRequestProductsV4|null $activeStatusListRequestProductsV4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4UpdateActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4UpdateActiveStatusAsync($xRequestTimestamp = null, $activeStatusListRequestProductsV4 = null, string $contentType = self::contentTypes['productsV4UpdateActiveStatus'][0])
    {
        return $this->productsV4UpdateActiveStatusAsyncWithHttpInfo($xRequestTimestamp, $activeStatusListRequestProductsV4, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4UpdateActiveStatusAsyncWithHttpInfo
     *
     * Update active status
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ActiveStatusListRequestProductsV4|null $activeStatusListRequestProductsV4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4UpdateActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4UpdateActiveStatusAsyncWithHttpInfo($xRequestTimestamp = null, $activeStatusListRequestProductsV4 = null, string $contentType = self::contentTypes['productsV4UpdateActiveStatus'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4';
        $request = $this->productsV4UpdateActiveStatusRequest($xRequestTimestamp, $activeStatusListRequestProductsV4, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4UpdateActiveStatus'
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\ActiveStatusListRequestProductsV4|null $activeStatusListRequestProductsV4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4UpdateActiveStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV4UpdateActiveStatusRequest($xRequestTimestamp = null, $activeStatusListRequestProductsV4 = null, string $contentType = self::contentTypes['productsV4UpdateActiveStatus'][0])
    {




        $resourcePath = '/v4/products/active-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($xRequestTimestamp !== null) {
            $headerParams['X-Request-Timestamp'] = ObjectSerializer::toHeaderValue($xRequestTimestamp);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($activeStatusListRequestProductsV4)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($activeStatusListRequestProductsV4));
            } else {
                $httpBody = $activeStatusListRequestProductsV4;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4UpdateProductVariationPrices
     *
     * Update product variation prices
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\SkuPricingProductsV4[]|null $skuPricingProductsV4 skuPricingProductsV4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4UpdateProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4
     */
    public function productsV4UpdateProductVariationPrices($xRequestTimestamp = null, $skuPricingProductsV4 = null, string $contentType = self::contentTypes['productsV4UpdateProductVariationPrices'][0])
    {
        list($response) = $this->productsV4UpdateProductVariationPricesWithHttpInfo($xRequestTimestamp, $skuPricingProductsV4, $contentType);
        return $response;
    }

    /**
     * Operation productsV4UpdateProductVariationPricesWithHttpInfo
     *
     * Update product variation prices
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\SkuPricingProductsV4[]|null $skuPricingProductsV4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4UpdateProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Otto\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4UpdateProductVariationPricesWithHttpInfo($xRequestTimestamp = null, $skuPricingProductsV4 = null, string $contentType = self::contentTypes['productsV4UpdateProductVariationPrices'][0])
    {
        $request = $this->productsV4UpdateProductVariationPricesRequest($xRequestTimestamp, $skuPricingProductsV4, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4UpdateProductVariationPricesAsync
     *
     * Update product variation prices
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\SkuPricingProductsV4[]|null $skuPricingProductsV4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4UpdateProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4UpdateProductVariationPricesAsync($xRequestTimestamp = null, $skuPricingProductsV4 = null, string $contentType = self::contentTypes['productsV4UpdateProductVariationPrices'][0])
    {
        return $this->productsV4UpdateProductVariationPricesAsyncWithHttpInfo($xRequestTimestamp, $skuPricingProductsV4, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4UpdateProductVariationPricesAsyncWithHttpInfo
     *
     * Update product variation prices
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\SkuPricingProductsV4[]|null $skuPricingProductsV4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4UpdateProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4UpdateProductVariationPricesAsyncWithHttpInfo($xRequestTimestamp = null, $skuPricingProductsV4 = null, string $contentType = self::contentTypes['productsV4UpdateProductVariationPrices'][0])
    {
        $returnType = '\OpenAPI\Client\Otto\Model\ProductProcessProgressProductsV4';
        $request = $this->productsV4UpdateProductVariationPricesRequest($xRequestTimestamp, $skuPricingProductsV4, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4UpdateProductVariationPrices'
     *
     * @param  string|null $xRequestTimestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     * @param  \OpenAPI\Client\Otto\Model\SkuPricingProductsV4[]|null $skuPricingProductsV4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsV4UpdateProductVariationPrices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsV4UpdateProductVariationPricesRequest($xRequestTimestamp = null, $skuPricingProductsV4 = null, string $contentType = self::contentTypes['productsV4UpdateProductVariationPrices'][0])
    {




        $resourcePath = '/v4/products/prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($xRequestTimestamp !== null) {
            $headerParams['X-Request-Timestamp'] = ObjectSerializer::toHeaderValue($xRequestTimestamp);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($skuPricingProductsV4)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($skuPricingProductsV4));
            } else {
                $httpBody = $skuPricingProductsV4;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
